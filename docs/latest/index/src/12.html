<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Aguacongas.Firebase;
using Aguacongas.Identity.Firebase.Internal;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Creates a new instance of a persistence store for the specified user type.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, string&gt; where TUser : IdentityUser&lt;string&gt;, new()
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserOnlyStore{TUser}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }

        protected override string ParseId(string id)
        {
            return id;
        }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the primary key for a role.&lt;/typeparam&gt;
    public abstract class UserOnlyStore&lt;TUser, TKey&gt; : UserOnlyStore&lt;TUser, TKey, IdentityUserClaim&lt;TKey&gt;, IdentityUserLogin&lt;TKey&gt;, IdentityUserToken&lt;TKey&gt;&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the primary key for a role.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public abstract class UserOnlyStore&lt;TUser, TKey, TUserClaim, TUserLogin, TUserToken&gt; :
        UserStoreBase&lt;TUser, TKey, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
        where TUserClaim : IdentityUserClaim&lt;TKey&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;TKey&gt;, new()
        where TUserToken : IdentityUserToken&lt;TKey&gt;, new()
    {
        private readonly IFirebaseClient _client;
        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The context used to access the store.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            if (client == null)
            {
                throw new ArgumentNullException(nameof(client));
            }
            _client = client;
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var response = await _client.PostAsync(&quot;users&quot;, user, cancellationToken);
            user.Id = ParseId(response.Data);
            user.ConcurrencyStamp = response.Etag;
            await _client.PutAsync($&quot;indexes/users-names/{user.NormalizedUserName}&quot;, user.Id, cancellationToken);
            if (!string.IsNullOrEmpty(user.NormalizedEmail))
            {
                await _client.PutAsync($&quot;indexes/users-email/{user.NormalizedEmail}&quot;, user.Id, cancellationToken);
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync($&quot;users/{user.Id}&quot;, user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
            {
                if (e.StatusCode == HttpStatusCode.PreconditionFailed)
                {
                    return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
                }
                throw;
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync($&quot;users/{user.Id}&quot;, cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
            {
                if (e.StatusCode == HttpStatusCode.PreconditionFailed)
                {
                    return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
                }
                throw;
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;($&quot;users/{userId}&quot;, cancellationToken, true);
            var user = response.Data;
            if (user != null)
            {
                user.ConcurrencyStamp = response.Etag;
            }

            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;string&gt;($&quot;indexes/users-names/{normalizedUserName}&quot;, cancellationToken);
            if (!string.IsNullOrEmpty(response.Data))
            {
                return await FindByIdAsync(response.Data, cancellationToken);
            }
            return default(TUser);
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                return data.Select(c =&gt; c.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                userClaims.AddRange(data);
            }

            await _client.PutAsync($&quot;claims/{user.Id}&quot;, userClaims, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                var matchedClaims = data.Where(uc =&gt; uc.ClaimValue == claim.Value &amp;&amp; uc.ClaimType == claim.Type);
                foreach (var matchedClaim in matchedClaims)
                {
                    matchedClaim.ClaimValue = newClaim.Value;
                    matchedClaim.ClaimType = newClaim.Type;
                }
                await _client.PutAsync($&quot;claims/{user.Id}&quot;, data, cancellationToken);
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            var response = await _client.GetAsync&lt;List&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                foreach (var claim in claims)
                {
                    data.RemoveAll(uc =&gt; uc.ClaimValue == claim.Value &amp;&amp; uc.ClaimType == claim.Type);
                }
                await _client.PutAsync($&quot;claims/{user.Id}&quot;, data, cancellationToken);
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            var response = await _client.GetAsync&lt;List&lt;TUserLogin&gt;&gt;($&quot;users/{user.Id}/logins&quot;, cancellationToken);
            var data = response.Data ?? new List&lt;TUserLogin&gt;(0);
            data.Add(CreateUserLogin(user, login));

            await _client.PutAsync($&quot;users/{user.Id}/logins&quot;, data, cancellationToken);
            await _client.PutAsync($&quot;indexes/provider-keys/{login.LoginProvider}/{login.ProviderKey}&quot;, user.Id, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.GetAsync&lt;List&lt;TUserLogin&gt;&gt;($&quot;users/{user.Id}/logins&quot;, cancellationToken);
            var data = response.Data ?? new List&lt;TUserLogin&gt;(0);
            data.RemoveAll(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);

            await _client.PutAsync($&quot;users/{user.Id}/logins&quot;, data, cancellationToken);
            await _client.DeleteAsync($&quot;indexes/provider-keys/{loginProvider}/{providerKey}&quot;, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var response = await _client.GetAsync&lt;List&lt;TUserLogin&gt;&gt;($&quot;users/{user.Id}/logins&quot;, cancellationToken);
            var data = response.Data ?? new List&lt;TUserLogin&gt;(0);

            return data.Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName)).ToList();
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            var response = await _client.GetAsync&lt;TKey&gt;($&quot;indexes/users-email/{normalizedEmail}&quot;, cancellationToken);
            if (response.Data != null)
            {
                return await FindByIdAsync(response.Data.ToString(), cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            var response = await _client.GetAsync&lt;IEnumerable&lt;KeyValue&lt;IEnumerable&lt;TUserClaim&gt;&gt;&gt;&gt;($&quot;claims&quot;, cancellationToken);
            var data = response.Data;
            var users = new List&lt;TUser&gt;();
            if (data != null)
            {
                var userIds = data.Where(uc =&gt; uc.Value.Any(c =&gt; c.ClaimType == claim.Type &amp;&amp; c.ClaimValue == c.ClaimValue))
                    .Select(uc =&gt; uc.Key);

                foreach (var userId in userIds)
                {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }
            }
            return users;
        }

        protected abstract TKey ParseId(string id);

        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(TKey userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(TKey userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserLogin&gt;&gt;($&quot;users/{userId}/logins&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                return data.SingleOrDefault(userLogin =&gt; userLogin.LoginProvider == loginProvider &amp;&amp; userLogin.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;TKey&gt;($&quot;indexes/provider-keys/{loginProvider}/{providerKey}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                return await FindUserLoginAsync(data, loginProvider, providerKey, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Find a user token if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider for the token.&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the token.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user token if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserToken&gt; FindTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;IEnumerable&lt;KeyValue&lt;KeyValue&lt;string&gt;&gt;&gt;&gt;($&quot;users/{user.Id}/tokens&quot;, cancellationToken);
            if (response.Data != null)
            {
                return response.Data
                    .Select(d =&gt; new TUserToken
                    {
                        UserId = user.Id,
                        LoginProvider = d.Key,
                        Name = d.Value.Key,
                        Value = d.Value.Value
                    })
                    .Where(t =&gt; t.LoginProvider == loginProvider &amp;&amp; t.Name == name)
                    .FirstOrDefault();
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Add a new user token.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;token&quot;&gt;The token to be added.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task AddUserTokenAsync(TUserToken token)
        {
            await _client.PutAsync($&quot;users/{token.UserId}/tokens/{token.LoginProvider}/{token.Name}&quot;, token);
        }


        /// &lt;summary&gt;
        /// Remove a new user token.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;token&quot;&gt;The token to be removed.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task RemoveUserTokenAsync(TUserToken token)
        {
            await _client.DeleteAsync($&quot;users/{token.UserId}/tokens/{token.LoginProvider}/{token.Name}&quot;);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[25,97,25,120,0],[25,121,25,122,0],[25,123,25,124,0],[28,9,28,10,0],[29,13,29,23,0],[30,9,30,10,0],[47,97,47,120,0],[47,121,47,122,0],[47,123,47,124,0],[83,97,83,144,0],[84,9,84,10,0],[85,13,85,32,0],[86,13,86,14,0],[87,17,87,65,0],[89,13,89,30,0],[90,9,90,10,0],[99,9,99,10,0],[100,13,100,62,0],[101,13,101,31,0],[102,13,102,30,0],[103,13,103,14,0],[104,17,104,63,0],[107,13,107,86,0],[108,13,108,46,0],[109,13,109,51,0],[110,13,110,114,0],[111,13,111,61,0],[112,13,112,14,0],[113,17,113,115,0],[114,13,114,14,0],[116,13,116,43,0],[117,9,117,10,0],[126,9,126,10,0],[127,13,127,62,0],[128,13,128,31,0],[129,13,129,30,0],[130,13,130,14,0],[131,17,131,63,0],[135,13,135,14,0],[136,17,136,129,0],[137,17,137,55,0],[138,13,138,14,0],[139,13,139,40,0],[140,13,140,14,0],[141,17,141,71,0],[142,17,142,18,0],[143,21,143,87,0],[145,17,145,23,0],[147,13,147,43,0],[148,9,148,10,0],[157,9,157,10,0],[158,13,158,62,0],[159,13,159,31,0],[160,13,160,30,0],[161,13,161,14,0],[162,17,162,63,0],[166,13,166,14,0],[167,17,167,111,0],[168,13,168,14,0],[169,13,169,40,0],[170,13,170,14,0],[171,17,171,71,0],[172,17,172,18,0],[173,21,173,87,0],[175,17,175,23,0],[177,13,177,43,0],[178,9,178,10,0],[189,9,189,10,0],[190,13,190,62,0],[191,13,191,31,0],[192,13,192,102,0],[193,13,193,38,0],[194,13,194,30,0],[195,13,195,14,0],[196,17,196,55,0],[197,13,197,14,0],[199,13,199,25,0],[200,9,200,10,0],[211,9,211,10,0],[212,13,212,62,0],[213,13,213,31,0],[214,13,214,123,0],[215,13,215,54,0],[216,13,216,14,0],[217,17,217,78,0],[219,13,219,35,0],[220,9,220,10,0],[229,9,229,10,0],[230,13,230,62,0],[231,13,231,31,0],[232,13,232,30,0],[233,13,233,14,0],[234,17,234,63,0],[236,13,236,116,0],[237,13,237,38,0],[238,13,238,30,0],[239,13,239,14,0],[240,17,240,41,0],[240,41,240,52,0],[240,52,240,63,0],[240,17,240,63,0],[242,13,242,39,0],[243,9,243,10,0],[253,9,253,10,0],[254,13,254,62,0],[255,13,255,31,0],[256,13,256,30,0],[257,13,257,14,0],[258,17,258,63,0],[260,13,260,32,0],[261,13,261,14,0],[262,17,262,65,0],[265,13,265,62,0],[265,62,265,86,0],[265,86,265,97,0],[265,13,265,97,0],[266,13,266,116,0],[267,13,267,38,0],[268,13,268,30,0],[269,13,269,14,0],[270,17,270,43,0],[271,13,271,14,0],[273,13,273,88,0],[274,9,274,10,0],[285,9,285,10,0],[286,13,286,62,0],[287,13,287,31,0],[288,13,288,30,0],[289,13,289,14,0],[290,17,290,63,0],[292,13,292,31,0],[293,13,293,14,0],[294,17,294,64,0],[296,13,296,34,0],[297,13,297,14,0],[298,17,298,67,0],[301,13,301,116,0],[302,13,302,38,0],[303,13,303,30,0],[304,13,304,14,0],[305,17,305,54,0],[305,54,305,112,0],[305,112,305,114,0],[305,17,305,114,0],[306,17,306,24,0],[306,26,306,42,0],[306,43,306,45,0],[306,46,306,59,0],[307,17,307,18,0],[308,21,308,62,0],[309,21,309,60,0],[310,17,310,18,0],[311,17,311,86,0],[312,13,312,14,0],[313,9,313,10,0],[323,9,323,10,0],[324,13,324,31,0],[325,13,325,30,0],[326,13,326,14,0],[327,17,327,63,0],[329,13,329,32,0],[330,13,330,14,0],[331,17,331,65,0],[334,13,334,109,0],[335,13,335,38,0],[336,13,336,30,0],[337,13,337,14,0],[338,17,338,24,0],[338,26,338,35,0],[338,36,338,38,0],[338,39,338,45,0],[339,17,339,18,0],[340,21,340,42,0],[340,42,340,100,0],[340,100,340,102,0],[340,21,340,102,0],[341,17,341,18,0],[342,17,342,86,0],[343,13,343,14,0],[344,9,344,10,0],[355,9,355,10,0],[356,13,356,62,0],[357,13,357,31,0],[358,13,358,30,0],[359,13,359,14,0],[360,17,360,63,0],[362,13,362,31,0],[363,13,363,14,0],[364,17,364,64,0],[367,13,367,115,0],[368,13,368,65,0],[369,13,369,52,0],[371,13,371,88,0],[372,13,372,132,0],[373,9,373,10,0],[385,9,385,10,0],[386,13,386,62,0],[387,13,387,31,0],[388,13,388,30,0],[389,13,389,14,0],[390,17,390,63,0],[392,13,392,115,0],[393,13,393,65,0],[394,13,394,33,0],[394,33,394,97,0],[394,97,394,99,0],[394,13,394,99,0],[396,13,396,88,0],[397,13,397,114,0],[398,9,398,10,0],[409,9,409,10,0],[410,13,410,62,0],[411,13,411,31,0],[412,13,412,30,0],[413,13,413,14,0],[414,17,414,63,0],[417,13,417,115,0],[418,13,418,65,0],[420,13,420,37,0],[420,37,420,109,0],[420,109,420,120,0],[420,13,420,120,0],[421,9,421,10,0],[434,9,434,10,0],[435,13,435,62,0],[436,13,436,31,0],[437,13,437,101,0],[438,13,438,35,0],[439,13,439,14,0],[440,17,440,81,0],[442,13,442,25,0],[443,9,443,10,0],[454,9,454,10,0],[455,13,455,62,0],[456,13,456,31,0],[458,13,458,118,0],[459,13,459,39,0],[460,13,460,14,0],[461,17,461,89,0],[463,13,463,25,0],[464,9,464,10,0],[475,9,475,10,0],[476,13,476,62,0],[477,13,477,31,0],[478,13,478,31,0],[479,13,479,14,0],[480,17,480,64,0],[483,13,483,129,0],[484,13,484,38,0],[485,13,485,43,0],[486,13,486,30,0],[487,13,487,14,0],[488,17,488,48,0],[488,48,488,66,0],[488,66,488,123,0],[488,123,488,124,0],[488,48,488,124,0],[488,124,489,35,0],[489,35,489,41,0],[489,41,489,43,0],[488,17,489,43,0],[491,17,491,24,0],[491,26,491,36,0],[491,37,491,39,0],[491,40,491,47,0],[492,17,492,18,0],[493,21,493,79,0],[494,21,494,38,0],[495,21,495,22,0],[496,25,496,41,0],[497,21,497,22,0],[498,17,498,18,0],[499,13,499,14,0],[500,13,500,26,0],[501,9,501,10,0],[512,9,512,10,0],[513,13,513,72,0],[514,9,514,10,0],[525,9,525,10,0],[526,13,526,121,0],[527,13,527,38,0],[528,13,528,30,0],[529,13,529,14,0],[530,17,530,58,0],[530,58,530,138,0],[530,138,530,140,0],[530,17,530,140,0],[532,13,532,25,0],[533,9,533,10,0],[543,9,543,10,0],[544,13,544,132,0],[545,13,545,38,0],[546,13,546,30,0],[547,13,547,14,0],[548,17,548,102,0],[550,13,550,25,0],[551,9,551,10,0],[562,9,562,10,0],[563,13,563,138,0],[564,13,564,39,0],[565,13,565,14,0],[566,17,567,34,0],[567,34,573,22,0],[573,22,574,33,0],[574,33,574,83,0],[574,83,575,39,0],[566,17,575,39,0],[577,13,577,25,0],[578,9,578,10,0],[586,9,586,10,0],[587,13,587,110,0],[588,9,588,10,0],[597,9,597,10,0],[598,13,598,106,0],[599,9,599,10,0]]);
    </script>
  </body>
</html>