<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Aguacongas.Firebase;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore: UserOnlyStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, IdentityUserClaim&lt;string&gt;, IdentityUserLogin&lt;string&gt;, IdentityUserToken&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt; :
        FirebaseUserStoreBase&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;string&gt;
        where TUserClaim : IdentityUserClaim&lt;string&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;string&gt;, new()
        where TUserToken : IdentityUserToken&lt;string&gt;, new()
    {
        private const string UsersTableName = &quot;users&quot;;
        private const string UserLoginsTableName = &quot;user-logins&quot;;
        private const string UserClaimsTableName = &quot;user-claims&quot;;
        private const string UserTokensTableName = &quot;user-tokens&quot;;

        private readonly IFirebaseClient _client;

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            if (client == null)
            {
                throw new ArgumentNullException(nameof(client));
            }
            _client = client;
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.PostAsync(GetFirebasePath(UsersTableName), user, cancellationToken);
            user.Id = response.Data;
            user.ConcurrencyStamp = response.Etag;
            
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync(GetFirebasePath(UsersTableName, user.Id), user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync(GetFirebasePath(UsersTableName, user.Id), cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;(GetFirebasePath(UsersTableName, userId), cancellationToken, true);
            var user = response.Data;
            if (user != null)
            {
                user.Id = userId;
                user.ConcurrencyStamp = response.Etag;
            }
            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach(var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
                
            }
            catch(FirebaseException e)
               when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
            }
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            
            if (data != null)
            {
                return data.Select(c =&gt; c.Value.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var taskList = new List&lt;Task&gt;(userClaims.Count);
            foreach(var userClaim in userClaims)
            {
                taskList.Add(_client.PostAsync(GetFirebasePath(UserClaimsTableName), userClaim, cancellationToken));
            }

            Task.WaitAll(taskList.ToArray());
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            data = data ?? new Dictionary&lt;string, TUserClaim&gt;();
            foreach(var kv in data)
            {
                var uc = kv.Value;
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;

                    await _client.PutAsync(GetFirebasePath(UserClaimsTableName, kv.Key), uc, cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                var taskList = new List&lt;Task&gt;(claims.Count());
                foreach (var claim in claims)
                {
                    var match = data.SingleOrDefault(kv =&gt; kv.Value.ClaimType == claim.Type &amp;&amp; kv.Value.ClaimValue == claim.Value);
                    if (match.Key != null)
                    {
                        taskList.Add(_client.DeleteAsync(GetFirebasePath(UserClaimsTableName, match.Key), cancellationToken));
                    }
                }

                Task.WaitAll(taskList.ToArray());
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            await _client.PostAsync(GetFirebasePath(UserLoginsTableName), CreateUserLogin(user, login), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = await GetUserLoginsAsync(user.Id, cancellationToken);

            foreach (var kv in data)
            {
                var login = kv.Value;
                if (login.LoginProvider == loginProvider &amp;&amp; login.ProviderKey == providerKey)
                {
                    await _client.DeleteAsync(GetFirebasePath(UserLoginsTableName, kv.Key), cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values
                    .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                    .ToList();
            }
            return new List&lt;UserLoginInfo&gt;(0);
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }

            if (data == null)
            {
                return new List&lt;TUser&gt;(0);
            }

            var userIds = data.Values.Where(c =&gt; c.ClaimValue == claim.Value).Select(c =&gt; c.UserId);
            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(userIds.Count());
            foreach (var userId in userIds)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(string userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId, cancellationToken);
            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;List&lt;TUserToken&gt;&gt;(GetFirebasePath(UserTokensTableName, user.Id), cancellationToken);
            return response.Data ?? new List&lt;TUserToken&gt;();
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            await _client.PutAsync(GetFirebasePath(UserTokensTableName, user.Id), tokens, cancellationToken);
        }

        protected virtual async Task&lt;Dictionary&lt;string, TUserLogin&gt;&gt; GetUserLoginsAsync(string userId, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }

            return data;
        }


        protected virtual void SetIndex(Dictionary&lt;string, object&gt; rules, string key, object index)
        {
            rules[key] = index;
        }

        internal async Task SetIndex(string onTable, object index, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;FirebaseRules&gt;(RulePath, cancellationToken);
            var rules = response.Data ?? new FirebaseRules();
            SetIndex(rules.Rules, onTable, index);
            await _client.PutAsync(RulePath, rules, cancellationToken);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,97,24,120,1],[24,121,24,122,1],[24,123,24,124,1],[39,97,39,120,1],[39,121,39,122,1],[39,123,39,124,1],[79,97,79,144,1],[80,9,80,10,1],[81,13,81,32,1],[82,13,82,14,0],[83,17,83,65,0],[85,13,85,30,1],[86,9,86,10,1],[95,9,95,10,1],[96,13,96,62,1],[97,13,97,31,1],[98,13,98,30,1],[99,13,99,14,1],[100,17,100,63,1],[102,13,102,110,1],[103,13,103,37,1],[104,13,104,51,1],[106,13,106,43,1],[107,9,107,10,1],[116,9,116,10,1],[117,13,117,62,1],[118,13,118,31,1],[119,13,119,30,1],[120,13,120,14,1],[121,17,121,63,1],[125,13,125,14,1],[126,17,126,151,1],[127,17,127,55,1],[128,13,128,14,1],[130,17,130,73,0],[131,13,131,14,0],[132,17,132,83,0],[135,13,135,43,1],[136,9,136,10,1],[145,9,145,10,1],[146,13,146,62,1],[147,13,147,31,1],[148,13,148,30,1],[149,13,149,14,1],[150,17,150,63,1],[154,13,154,14,1],[155,17,155,133,1],[156,13,156,14,1],[158,17,158,73,0],[159,13,159,14,0],[160,17,160,83,0],[162,13,162,43,1],[163,9,163,10,1],[174,9,174,10,1],[175,13,175,62,1],[176,13,176,31,1],[177,13,177,124,1],[178,13,178,38,1],[179,13,179,30,1],[180,13,180,14,1],[181,17,181,34,1],[182,17,182,55,1],[183,13,183,14,1],[184,13,184,25,1],[185,9,185,10,1],[196,9,196,10,1],[197,13,197,62,1],[198,13,198,31,1],[200,13,200,14,1],[201,17,201,209,1],[202,17,202,24,1],[202,25,202,31,1],[202,32,202,34,1],[202,35,202,48,1],[203,17,203,18,1],[204,21,204,75,1],[206,17,206,29,1],[210,16,210,91,1],[211,13,211,14,1],[212,17,212,84,1],[214,17,214,209,1],[215,17,215,24,1],[215,26,215,32,0],[215,33,215,35,1],[215,36,215,49,1],[216,17,216,18,0],[217,21,217,75,0],[219,17,219,29,1],[221,9,221,10,1],[230,9,230,10,1],[231,13,231,62,1],[232,13,232,31,1],[233,13,233,30,1],[234,13,234,14,1],[235,17,235,63,1],[240,13,240,14,1],[241,17,241,196,1],[242,17,242,38,1],[243,13,243,14,1],[245,17,245,92,1],[246,13,246,14,1],[247,17,247,94,1],[249,17,249,202,1],[250,17,250,38,1],[251,13,251,14,1],[253,13,253,30,1],[254,13,254,14,1],[255,17,255,41,1],[255,41,255,58,1],[255,58,255,69,1],[255,17,255,69,1],[257,13,257,39,0],[258,9,258,10,1],[268,9,268,10,1],[269,13,269,62,1],[270,13,270,31,1],[271,13,271,30,1],[272,13,272,14,1],[273,17,273,63,1],[275,13,275,32,1],[276,13,276,14,1],[277,17,277,65,1],[280,13,280,62,1],[280,62,280,86,1],[280,86,280,97,1],[280,13,280,97,1],[281,13,281,61,1],[282,13,282,20,1],[282,21,282,34,1],[282,35,282,37,1],[282,38,282,48,1],[283,13,283,14,1],[284,17,284,117,1],[285,13,285,14,1],[287,13,287,46,1],[288,9,288,10,1],[299,9,299,10,1],[300,13,300,62,1],[301,13,301,31,1],[302,13,302,30,1],[303,13,303,14,1],[304,17,304,63,1],[306,13,306,31,1],[307,13,307,14,0],[308,17,308,64,0],[310,13,310,34,1],[311,13,311,14,0],[312,17,312,67,0],[317,13,317,14,1],[318,17,318,196,1],[319,17,319,38,1],[320,13,320,14,1],[322,17,322,92,0],[323,13,323,14,0],[324,17,324,94,0],[326,17,326,202,0],[327,17,327,38,0],[328,13,328,14,0],[330,13,330,65,1],[331,13,331,20,1],[331,21,331,27,1],[331,28,331,30,1],[331,31,331,35,1],[332,13,332,14,1],[333,17,333,35,1],[334,17,334,80,1],[335,17,335,18,1],[336,21,336,50,1],[337,21,337,52,1],[339,21,339,113,1],[340,17,340,18,1],[341,13,341,14,1],[342,9,342,10,1],[352,9,352,10,1],[353,13,353,31,1],[354,13,354,30,1],[355,13,355,14,1],[356,17,356,63,1],[358,13,358,32,1],[359,13,359,14,1],[360,17,360,65,1],[365,13,365,14,1],[366,17,366,196,1],[367,17,367,38,1],[368,13,368,14,1],[370,17,370,92,0],[371,13,371,14,0],[372,17,372,94,0],[374,17,374,202,0],[375,17,375,38,0],[376,13,376,14,0],[378,13,378,30,1],[379,13,379,14,1],[380,17,380,63,1],[381,17,381,24,1],[381,26,381,35,1],[381,36,381,38,1],[381,39,381,45,1],[382,17,382,18,1],[383,21,383,60,1],[383,60,383,130,1],[383,130,383,132,1],[383,21,383,132,1],[384,21,384,43,1],[385,21,385,22,1],[386,25,386,127,1],[387,21,387,22,1],[388,17,388,18,1],[390,17,390,50,1],[391,13,391,14,1],[392,9,392,10,1],[403,9,403,10,1],[404,13,404,62,1],[405,13,405,31,1],[406,13,406,30,1],[407,13,407,14,1],[408,17,408,63,1],[410,13,410,31,1],[411,13,411,14,1],[412,17,412,64,1],[415,13,415,124,1],[416,9,416,10,1],[428,9,428,10,1],[429,13,429,62,1],[430,13,430,31,1],[431,13,431,30,1],[432,13,432,14,1],[433,17,433,63,1],[436,13,436,77,1],[438,13,438,20,1],[438,22,438,28,1],[438,29,438,31,1],[438,32,438,36,1],[439,13,439,14,1],[440,17,440,38,1],[441,17,441,94,1],[442,17,442,18,1],[443,21,443,112,1],[444,17,444,18,1],[445,13,445,14,1],[446,9,446,10,1],[457,9,457,10,1],[458,13,458,62,1],[459,13,459,31,1],[460,13,460,30,1],[461,13,461,14,1],[462,17,462,63,1],[467,13,467,14,1],[468,17,468,196,1],[469,17,469,38,1],[470,13,470,14,1],[472,17,472,92,1],[473,13,473,14,1],[474,17,474,90,1],[476,17,476,202,1],[477,17,477,38,1],[478,13,478,14,1],[480,13,480,30,1],[481,13,481,14,1],[482,17,483,34,1],[483,34,483,106,1],[483,106,484,31,1],[482,17,484,31,1],[486,13,486,47,0],[487,9,487,10,1],[500,9,500,10,1],[501,13,501,62,1],[502,13,502,31,1],[503,13,503,101,1],[504,13,504,35,1],[505,13,505,14,1],[506,17,506,81,1],[508,13,508,25,1],[509,9,509,10,1],[520,9,520,10,1],[521,13,521,62,1],[522,13,522,31,1],[525,13,525,14,1],[526,17,526,203,1],[527,17,527,24,1],[527,26,527,32,1],[527,33,527,35,1],[527,36,527,49,1],[528,17,528,18,1],[529,21,529,75,1],[531,17,531,29,1],[535,17,535,92,0],[536,13,536,14,0],[537,17,537,84,0],[539,17,539,203,0],[540,17,540,24,0],[540,26,540,32,0],[540,33,540,35,0],[540,36,540,49,0],[541,17,541,18,0],[542,21,542,75,0],[544,17,544,29,0],[547,9,547,10,1],[558,9,558,10,1],[559,13,559,62,1],[560,13,560,31,1],[561,13,561,31,1],[562,13,562,14,0],[563,17,563,64,0],[568,13,568,14,1],[569,17,569,202,1],[570,17,570,38,1],[571,13,571,14,1],[573,17,573,92,0],[574,13,574,14,0],[575,17,575,94,0],[577,17,577,208,0],[578,17,578,38,0],[579,13,579,14,0],[581,13,581,30,1],[582,13,582,14,0],[583,17,583,43,0],[586,13,586,50,1],[586,50,586,77,1],[586,77,586,91,1],[586,91,586,99,1],[586,99,586,101,1],[586,13,586,101,1],[587,13,587,52,1],[588,13,588,60,1],[589,13,589,20,1],[589,22,589,32,1],[589,33,589,35,1],[589,36,589,43,1],[590,13,590,14,1],[591,17,591,51,1],[591,51,591,52,1],[591,52,592,21,1],[592,21,592,79,1],[592,79,593,21,1],[593,21,593,38,1],[593,38,594,21,1],[594,21,594,22,1],[594,22,595,25,1],[595,25,595,41,1],[595,41,596,21,1],[596,21,596,22,1],[596,22,597,17,1],[597,17,597,18,1],[597,18,597,21,1],[591,17,597,21,1],[598,13,598,14,1],[600,13,600,46,1],[602,13,602,35,1],[603,9,603,10,1],[614,9,614,10,0],[615,13,615,94,0],[616,9,616,10,0],[626,9,626,10,0],[627,13,627,86,0],[628,9,628,10,0],[637,9,637,10,1],[638,13,638,64,1],[639,9,639,10,1],[649,9,649,10,1],[650,13,650,73,1],[651,9,651,10,1],[660,9,660,10,1],[661,13,661,72,1],[662,9,662,10,1],[673,9,673,10,0],[674,13,674,76,0],[675,13,675,30,0],[676,13,676,14,0],[677,17,677,56,0],[677,56,677,120,0],[677,120,677,122,0],[677,17,677,122,0],[679,13,679,25,0],[680,9,680,10,0],[690,9,690,10,1],[693,13,693,14,1],[694,17,694,205,1],[695,17,695,38,1],[696,13,696,14,1],[698,17,698,92,1],[699,13,699,14,1],[700,17,700,90,1],[702,17,702,211,1],[703,17,703,38,1],[704,13,704,14,1],[706,13,706,30,1],[707,13,707,14,1],[708,17,708,56,1],[708,56,708,120,1],[708,120,708,122,1],[708,17,708,122,1],[710,13,710,25,0],[711,9,711,10,1],[720,9,720,10,1],[721,13,721,135,1],[722,13,722,60,1],[723,9,723,10,1],[733,9,733,10,1],[734,13,734,110,1],[735,9,735,10,1],[738,9,738,10,1],[741,13,741,14,1],[742,17,742,195,1],[743,17,743,38,1],[744,13,744,14,1],[746,17,746,92,0],[747,13,747,14,0],[748,17,748,90,0],[750,17,750,201,0],[751,17,751,38,0],[752,13,752,14,0],[754,13,754,25,1],[755,9,755,10,1],[759,9,759,10,1],[760,13,760,32,1],[761,9,761,10,1],[764,9,764,10,1],[765,13,765,95,1],[766,13,766,62,1],[767,13,767,51,1],[768,13,768,72,1],[769,9,769,10,1]]);
    </script>
  </body>
</html>