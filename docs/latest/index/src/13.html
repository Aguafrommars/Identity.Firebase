<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;
using Aguacongas.Firebase;
using Aguacongas.Identity.Firebase.Internal;
using Microsoft.AspNetCore.Identity;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for users, using the default implementation
    /// of &lt;see cref=&quot;IdentityUser{TKey}&quot;/&gt; with a string as a primary key.
    /// &lt;/summary&gt;
    public class UserStore : UserStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Creates a new instance of a persistence store for the specified user type.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserStore&lt;TUser&gt; : UserStore&lt;TUser, IdentityRole, string&gt;
        where TUser : IdentityUser&lt;string&gt;, new()
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }

        protected override string ParseId(string id)
        {
            return id;
        }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TRole&quot;&gt;The type representing a role.&lt;/typeparam&gt;
    public class UserStore&lt;TUser, TRole&gt; : UserStore&lt;TUser, TRole, string&gt;
        where TUser : IdentityUser&lt;string&gt;
        where TRole : IdentityRole&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TContext}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }

        protected override string ParseId(string id)
        {
            return id;
        }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TRole&quot;&gt;The type representing a role.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the primary key for a role.&lt;/typeparam&gt;
    public abstract class UserStore&lt;TUser, TRole, TKey&gt; : UserStore&lt;TUser, TRole, TKey, IdentityUserClaim&lt;TKey&gt;, IdentityUserRole&lt;TKey&gt;, IdentityUserLogin&lt;TKey&gt;, IdentityUserToken&lt;TKey&gt;, IdentityRoleClaim&lt;TKey&gt;&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TRole : IdentityRole&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TContext, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;The &lt;see cref=&quot;DbContext&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TRole&quot;&gt;The type representing a role.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TKey&quot;&gt;The type of the primary key for a role.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserRole&quot;&gt;The type representing a user role.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TRoleClaim&quot;&gt;The type representing a role claim.&lt;/typeparam&gt;
    public abstract class UserStore&lt;TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim&gt; :
        UserStoreBase&lt;TUser, TRole, TKey, TUserClaim, TUserRole, TUserLogin, TUserToken, TRoleClaim&gt;
        where TUser : IdentityUser&lt;TKey&gt;
        where TRole : IdentityRole&lt;TKey&gt;
        where TKey : IEquatable&lt;TKey&gt;
        where TUserClaim : IdentityUserClaim&lt;TKey&gt;, new()
        where TUserRole : IdentityUserRole&lt;TKey&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;TKey&gt;, new()
        where TUserToken : IdentityUserToken&lt;TKey&gt;, new()
        where TRoleClaim : IdentityRoleClaim&lt;TKey&gt;, new()
    {
        private readonly IFirebaseClient _client;

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The client used to access the store.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            if (client == null)
            {
                throw new ArgumentNullException(nameof(client));
            }
            _client = client;
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var response = await _client.PostAsync(&quot;users&quot;, user, cancellationToken);
            user.Id = ParseId(response.Data);
            user.ConcurrencyStamp = response.Etag;
            await _client.PutAsync($&quot;indexes/users-names/{user.NormalizedUserName}&quot;, user.Id, cancellationToken);

            if(!string.IsNullOrEmpty(user.NormalizedEmail))
            {
                await _client.PutAsync($&quot;indexes/users-email/{user.NormalizedEmail}&quot;, user.Id, cancellationToken);
            }            

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public override async Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync($&quot;users/{user.Id}&quot;, user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
            {
                if (e.StatusCode == HttpStatusCode.PreconditionFailed)
                {
                    return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
                }
                throw;
            }
            
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync($&quot;users/{user.Id}&quot;, cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
            {
                if (e.StatusCode == HttpStatusCode.PreconditionFailed)
                {
                    return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
                }
                throw;
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;($&quot;users/{userId}&quot;, cancellationToken, true);
            var user = response.Data;
            if(user != null)
            {
                user.ConcurrencyStamp = response.Etag;
            }
            
            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;string&gt;($&quot;indexes/users-names/{normalizedUserName}&quot;, cancellationToken);
            if (!string.IsNullOrEmpty(response.Data))
            {
                return await FindByIdAsync(response.Data, cancellationToken);
            }
            return default(TUser);
        }

        /// &lt;summary&gt;
        /// Adds the given &lt;paramref name=&quot;normalizedRoleName&quot;/&gt; to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the role to.&lt;/param&gt;
        /// &lt;param name=&quot;normalizedRoleName&quot;&gt;The role to add.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task AddToRoleAsync(TUser user, string normalizedRoleName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (string.IsNullOrWhiteSpace(normalizedRoleName))
            {
                throw new ArgumentNullException(nameof(normalizedRoleName));
            }
            var roleEntity = await FindRoleAsync(normalizedRoleName, cancellationToken);
            if (roleEntity == null)
            {
                throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, &quot;RoleNotFound {0}&quot;, normalizedRoleName));
            }

            var userRole = CreateUserRole(user, roleEntity);

            await _client.PutAsync($&quot;users/{user.Id}/roles/{roleEntity.Id}&quot;, userRole, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the given &lt;paramref name=&quot;normalizedRoleName&quot;/&gt; from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the role from.&lt;/param&gt;
        /// &lt;param name=&quot;normalizedRoleName&quot;&gt;The role to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveFromRoleAsync(TUser user, string normalizedRoleName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (string.IsNullOrWhiteSpace(normalizedRoleName))
            {
                throw new ArgumentNullException(nameof(normalizedRoleName));
            }
            var roleEntity = await FindRoleAsync(normalizedRoleName, cancellationToken);
            if (roleEntity != null)
            {
                var userRole = await FindUserRoleAsync(user.Id, roleEntity.Id, cancellationToken);
                if (userRole != null)
                {
                    await _client.DeleteAsync($&quot;users/{user.Id}/roles/{roleEntity.Id}&quot;, cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Retrieves the roles the specified &lt;paramref name=&quot;user&quot;/&gt; is a member of.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose roles should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the roles the user is a member of.&lt;/returns&gt;
        public override async Task&lt;IList&lt;string&gt;&gt; GetRolesAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var userId = user.Id;

            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserRole&gt;&gt;($&quot;users/{userId}/roles&quot;, cancellationToken);
            var userRoles = response.Data;
            if (userRoles != null)
            {
                var rolesResponse = await _client.GetAsync&lt;IEnumerable&lt;TRole&gt;&gt;($&quot;roles&quot;, cancellationToken);
                var roles = rolesResponse.Data;
                if (roles != null)
                {
                    return (from userRole in userRoles
                           join role in roles on userRole.RoleId equals role.Id
                           where userRole.UserId.Equals(userId)
                           select role.Name).ToList();
                }
            }
            return new List&lt;string&gt;(0);
        }

        /// &lt;summary&gt;
        /// Returns a flag indicating if the specified user is a member of the give &lt;paramref name=&quot;normalizedRoleName&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose role membership should be checked.&lt;/param&gt;
        /// &lt;param name=&quot;normalizedRoleName&quot;&gt;The role to check membership of&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; containing a flag indicating if the specified user is a member of the given group. If the 
        /// user is a member of the group the returned value with be true, otherwise it will be false.&lt;/returns&gt;
        public override async Task&lt;bool&gt; IsInRoleAsync(TUser user, string normalizedRoleName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (string.IsNullOrWhiteSpace(normalizedRoleName))
            {
                throw new ArgumentNullException(nameof(normalizedRoleName));
            }
            var role = await FindRoleAsync(normalizedRoleName, cancellationToken);
            if (role != null)
            {
                var userRole = await FindUserRoleAsync(user.Id, role.Id, cancellationToken);
                return userRole != null;
            }
            return false;
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                return data.Select(c =&gt; c.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                userClaims.AddRange(data);
            }
            
            await _client.PutAsync($&quot;claims/{user.Id}&quot;, userClaims, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                var matchedClaims = data.Where(uc =&gt; uc.ClaimValue == claim.Value &amp;&amp; uc.ClaimType == claim.Type);
                foreach (var matchedClaim in matchedClaims)
                {
                    matchedClaim.ClaimValue = newClaim.Value;
                    matchedClaim.ClaimType = newClaim.Type;
                }
                await _client.PutAsync($&quot;claims/{user.Id}&quot;, data, cancellationToken);
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            var response = await _client.GetAsync&lt;List&lt;TUserClaim&gt;&gt;($&quot;claims/{user.Id}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                foreach (var claim in claims)
                {
                    data.RemoveAll(uc =&gt; uc.ClaimValue == claim.Value &amp;&amp; uc.ClaimType == claim.Type);
                }
                await _client.PutAsync($&quot;claims/{user.Id}&quot;, data, cancellationToken);
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            var response = await _client.GetAsync&lt;List&lt;TUserLogin&gt;&gt;($&quot;users/{user.Id}/logins&quot;, cancellationToken);
            var data = response.Data ?? new List&lt;TUserLogin&gt;(0);
            data.Add(CreateUserLogin(user, login));

            await _client.PutAsync($&quot;users/{user.Id}/logins&quot;, data, cancellationToken);
            await _client.PutAsync($&quot;indexes/provider-keys/{login.LoginProvider}/{login.ProviderKey}&quot;, user.Id, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.GetAsync&lt;List&lt;TUserLogin&gt;&gt;($&quot;users/{user.Id}/logins&quot;, cancellationToken);
            var data = response.Data ?? new List&lt;TUserLogin&gt;(0);
            data.RemoveAll(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);

            await _client.PutAsync($&quot;users/{user.Id}/logins&quot;, data, cancellationToken);
            await _client.DeleteAsync($&quot;indexes/provider-keys/{loginProvider}/{providerKey}&quot;, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var response = await _client.GetAsync&lt;List&lt;TUserLogin&gt;&gt;($&quot;users/{user.Id}/logins&quot;, cancellationToken);
            var data = response.Data ?? new List&lt;TUserLogin&gt;(0);

            return data.Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName)).ToList();
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            var response = await _client.GetAsync&lt;TKey&gt;($&quot;indexes/users-email/{normalizedEmail}&quot;, cancellationToken);
            if (response.Data != null)
            {
                return await FindByIdAsync(response.Data.ToString(), cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            var response = await _client.GetAsync&lt;IEnumerable&lt;KeyValue&lt;IEnumerable&lt;TUserClaim&gt;&gt;&gt;&gt;($&quot;claims&quot;, cancellationToken);
            var data = response.Data;
            var users = new List&lt;TUser&gt;();
            if (data != null)
            {
                var userIds = data.Where(uc =&gt; uc.Value.Any(c =&gt; c.ClaimType == claim.Type &amp;&amp; c.ClaimValue == c.ClaimValue))
                    .Select(uc =&gt; uc.Key);

                foreach (var userId in userIds)
                {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }
            }
            return users;
        }

        /// &lt;summary&gt;
        /// Retrieves all users in the specified role.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedRoleName&quot;&gt;The role whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that are in the specified role. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersInRoleAsync(string normalizedRoleName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (string.IsNullOrEmpty(normalizedRoleName))
            {
                throw new ArgumentNullException(nameof(normalizedRoleName));
            }

            var role = await FindRoleAsync(normalizedRoleName, cancellationToken);
            var users = new List&lt;TUser&gt;();

            if (role != null)
            {
                var response = await _client.GetAsync&lt;IEnumerable&lt;KeyValue&lt;TKey&gt;&gt;&gt;($&quot;roles/{normalizedRoleName}&quot;, cancellationToken);
                var data = response.Data;
                if (data != null)
                {
                    foreach(var keyValues in data)
                    {
                        var user = await FindByIdAsync(keyValues.Key, cancellationToken);
                        if (user != null)
                        {
                            users.Add(user);
                        }
                    }
                }
            }
            return users;
        }

        protected abstract TKey ParseId(string id);

        /// &lt;summary&gt;
        /// Return a role with the normalized name if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedRoleName&quot;&gt;The normalized role name.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The role if it exists.&lt;/returns&gt;
        protected override async Task&lt;TRole&gt; FindRoleAsync(string normalizedRoleName, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;string&gt;($&quot;indexes/role-name/{normalizedRoleName}&quot;, cancellationToken);
            if (response.Data == null)
            {
                return null;
            }

            var roleResponse = await _client.GetAsync&lt;TRole&gt;($&quot;roles/{response.Data}&quot;, cancellationToken, true);
            var role = roleResponse.Data;
            if (role != null)
            {
                role.ConcurrencyStamp = response.Etag;
            }            

            return role;
        }

        /// &lt;summary&gt;
        /// Return a user role for the userId and roleId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;roleId&quot;&gt;The role&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user role if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserRole&gt; FindUserRoleAsync(TKey userId, TKey roleId, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;TUserRole&gt;($&quot;users/{userId}/roles/{roleId}&quot;, cancellationToken);

            return response.Data;
        }

        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(TKey userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(TKey userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;IEnumerable&lt;TUserLogin&gt;&gt;($&quot;users/{userId}/logins&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                return data.SingleOrDefault(userLogin =&gt; userLogin.LoginProvider == loginProvider &amp;&amp; userLogin.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;TKey&gt;($&quot;indexes/provider-keys/{loginProvider}/{providerKey}&quot;, cancellationToken);
            var data = response.Data;
            if (data != null)
            {
                return await FindUserLoginAsync(data, loginProvider, providerKey, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Find a user token if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider for the token.&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;The name of the token.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user token if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserToken&gt; FindTokenAsync(TUser user, string loginProvider, string name, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;IEnumerable&lt;KeyValue&lt;KeyValue&lt;string&gt;&gt;&gt;&gt;($&quot;users/{user.Id}/tokens&quot;, cancellationToken);
            if (response.Data != null)
            {
                return response.Data
                    .Select(d =&gt; new TUserToken
                    {
                        UserId = user.Id,
                        LoginProvider = d.Key,
                        Name = d.Value.Key,
                        Value = d.Value.Value
                    })
                    .Where(t =&gt; t.LoginProvider == loginProvider &amp;&amp; t.Name == name)
                    .FirstOrDefault();
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Add a new user token.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;token&quot;&gt;The token to be added.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task AddUserTokenAsync(TUserToken token)
        {
            await _client.PutAsync($&quot;users/{token.UserId}/tokens/{token.LoginProvider}/{token.Name}&quot;, token);
        }


        /// &lt;summary&gt;
        /// Remove a new user token.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;token&quot;&gt;The token to be removed.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task RemoveUserTokenAsync(TUserToken token)
        {
            await _client.DeleteAsync($&quot;users/{token.UserId}/tokens/{token.LoginProvider}/{token.Name}&quot;);
        }
    }

}

    </pre>
    <script type="text/javascript">
      highlightRanges([[27,93,27,116,1],[27,117,27,118,1],[27,119,27,120,1],[42,93,42,116,1],[42,117,42,118,1],[42,119,42,120,1],[45,9,45,10,0],[46,13,46,23,0],[47,9,47,10,0],[64,93,64,116,1],[64,117,64,118,1],[64,119,64,120,1],[67,9,67,10,1],[68,13,68,23,1],[69,9,69,10,1],[88,93,88,116,1],[88,117,88,118,1],[88,119,88,120,1],[120,93,120,140,1],[121,9,121,10,1],[122,13,122,32,1],[123,13,123,14,1],[124,17,124,65,1],[126,13,126,30,1],[127,9,127,10,1],[136,9,136,10,1],[137,13,137,62,1],[138,13,138,31,1],[139,13,139,30,1],[140,13,140,14,1],[141,17,141,63,1],[144,13,144,86,1],[145,13,145,46,1],[146,13,146,51,1],[147,13,147,114,1],[149,13,149,60,1],[150,13,150,14,1],[151,17,151,115,1],[152,13,152,14,1],[154,13,154,43,1],[155,9,155,10,1],[164,9,164,10,1],[165,13,165,62,1],[166,13,166,31,1],[167,13,167,30,1],[168,13,168,14,1],[169,17,169,63,1],[173,13,173,14,1],[174,17,174,129,1],[175,17,175,55,1],[176,13,176,14,1],[177,13,177,40,1],[178,13,178,14,1],[179,17,179,71,1],[180,17,180,18,1],[181,21,181,87,1],[183,17,183,23,0],[186,13,186,43,1],[187,9,187,10,1],[196,9,196,10,1],[197,13,197,62,1],[198,13,198,31,1],[199,13,199,30,1],[200,13,200,14,1],[201,17,201,63,1],[205,13,205,14,1],[206,17,206,111,1],[207,13,207,14,1],[208,13,208,40,1],[209,13,209,14,1],[210,17,210,71,1],[211,17,211,18,1],[212,21,212,87,1],[214,17,214,23,0],[216,13,216,43,1],[217,9,217,10,1],[228,9,228,10,1],[229,13,229,62,1],[230,13,230,31,1],[231,13,231,102,1],[232,13,232,38,1],[233,13,233,29,1],[234,13,234,14,1],[235,17,235,55,1],[236,13,236,14,1],[238,13,238,25,1],[239,9,239,10,1],[250,9,250,10,1],[251,13,251,62,1],[252,13,252,31,1],[253,13,253,123,1],[254,13,254,54,1],[255,13,255,14,0],[256,17,256,78,0],[258,13,258,35,1],[259,9,259,10,1],[269,9,269,10,1],[270,13,270,62,1],[271,13,271,31,1],[272,13,272,30,1],[273,13,273,14,1],[274,17,274,63,1],[276,13,276,63,1],[277,13,277,14,1],[278,17,278,77,1],[280,13,280,89,1],[281,13,281,36,1],[282,13,282,14,1],[283,17,283,136,1],[286,13,286,61,0],[288,13,288,107,0],[289,9,289,10,0],[299,9,299,10,1],[300,13,300,62,1],[301,13,301,31,1],[302,13,302,30,1],[303,13,303,14,1],[304,17,304,63,1],[306,13,306,63,1],[307,13,307,14,1],[308,17,308,77,1],[310,13,310,89,0],[311,13,311,36,0],[312,13,312,14,0],[313,17,313,99,0],[314,17,314,38,0],[315,17,315,18,0],[316,21,316,108,0],[317,17,317,18,0],[318,13,318,14,0],[319,9,319,10,0],[328,9,328,10,1],[329,13,329,62,1],[330,13,330,31,1],[331,13,331,30,1],[332,13,332,14,1],[333,17,333,63,1],[335,13,335,34,0],[337,13,337,119,0],[338,13,338,43,0],[339,13,339,35,0],[340,13,340,14,0],[341,17,341,109,0],[342,17,342,48,0],[343,17,343,35,0],[344,17,344,18,0],[345,21,346,28,0],[346,28,346,50,0],[346,50,346,65,0],[346,65,346,80,0],[346,28,346,80,0],[346,80,346,73,0],[346,73,346,80,0],[346,80,347,34,0],[347,34,347,64,0],[347,64,348,35,0],[348,35,348,44,0],[348,44,348,55,0],[345,21,348,55,0],[350,13,350,14,0],[351,13,351,40,0],[352,9,352,10,0],[363,9,363,10,1],[364,13,364,62,1],[365,13,365,31,1],[366,13,366,30,1],[367,13,367,14,1],[368,17,368,63,1],[370,13,370,63,1],[371,13,371,14,1],[372,17,372,77,1],[374,13,374,83,1],[375,13,375,30,1],[376,13,376,14,0],[377,17,377,93,0],[378,17,378,41,0],[380,13,380,26,1],[381,9,381,10,1],[390,9,390,10,1],[391,13,391,62,1],[392,13,392,31,1],[393,13,393,30,1],[394,13,394,14,1],[395,17,395,63,1],[397,13,397,116,0],[398,13,398,38,0],[399,13,399,30,0],[400,13,400,14,0],[401,17,401,41,0],[401,41,401,52,0],[401,52,401,63,0],[401,17,401,63,0],[403,13,403,39,0],[404,9,404,10,0],[414,9,414,10,1],[415,13,415,62,1],[416,13,416,31,1],[417,13,417,30,1],[418,13,418,14,1],[419,17,419,63,1],[421,13,421,32,1],[422,13,422,14,1],[423,17,423,65,1],[426,13,426,62,0],[426,62,426,86,0],[426,86,426,97,0],[426,13,426,97,0],[427,13,427,116,0],[428,13,428,38,0],[429,13,429,30,0],[430,13,430,14,0],[431,17,431,43,0],[432,13,432,14,0],[434,13,434,88,0],[435,9,435,10,0],[446,9,446,10,1],[447,13,447,62,1],[448,13,448,31,1],[449,13,449,30,1],[450,13,450,14,1],[451,17,451,63,1],[453,13,453,31,0],[454,13,454,14,0],[455,17,455,64,0],[457,13,457,34,0],[458,13,458,14,0],[459,17,459,67,0],[462,13,462,116,0],[463,13,463,38,0],[464,13,464,30,0],[465,13,465,14,0],[466,17,466,54,0],[466,54,466,112,0],[466,112,466,114,0],[466,17,466,114,0],[467,17,467,24,0],[467,26,467,42,0],[467,43,467,45,0],[467,46,467,59,0],[468,17,468,18,0],[469,21,469,62,0],[470,21,470,60,0],[471,17,471,18,0],[472,17,472,86,0],[473,13,473,14,0],[474,9,474,10,0],[484,9,484,10,1],[485,13,485,31,1],[486,13,486,30,1],[487,13,487,14,1],[488,17,488,63,1],[490,13,490,32,1],[491,13,491,14,1],[492,17,492,65,1],[495,13,495,109,0],[496,13,496,38,0],[497,13,497,30,0],[498,13,498,14,0],[499,17,499,24,0],[499,26,499,35,0],[499,36,499,38,0],[499,39,499,45,0],[500,17,500,18,0],[501,21,501,42,0],[501,42,501,100,0],[501,100,501,102,0],[501,21,501,102,0],[502,17,502,18,0],[503,17,503,86,0],[504,13,504,14,0],[505,9,505,10,0],[516,9,516,10,1],[517,13,517,62,1],[518,13,518,31,1],[519,13,519,30,1],[520,13,520,14,1],[521,17,521,63,1],[523,13,523,31,1],[524,13,524,14,1],[525,17,525,64,1],[528,13,528,115,0],[529,13,529,65,0],[530,13,530,52,0],[532,13,532,88,0],[533,13,533,132,0],[534,9,534,10,0],[546,9,546,10,1],[547,13,547,62,1],[548,13,548,31,1],[549,13,549,30,1],[550,13,550,14,1],[551,17,551,63,1],[553,13,553,115,0],[554,13,554,65,0],[555,13,555,33,0],[555,33,555,97,0],[555,97,555,99,0],[555,13,555,99,0],[557,13,557,88,0],[558,13,558,114,0],[559,9,559,10,0],[570,9,570,10,1],[571,13,571,62,1],[572,13,572,31,1],[573,13,573,30,1],[574,13,574,14,1],[575,17,575,63,1],[578,13,578,115,0],[579,13,579,65,0],[581,13,581,37,0],[581,37,581,109,0],[581,109,581,120,0],[581,13,581,120,0],[582,9,582,10,0],[595,9,595,10,1],[596,13,596,62,1],[597,13,597,31,1],[598,13,598,101,0],[599,13,599,35,0],[600,13,600,14,0],[601,17,601,81,0],[603,13,603,25,0],[604,9,604,10,0],[615,9,615,10,0],[616,13,616,62,0],[617,13,617,31,0],[619,13,619,118,0],[620,13,620,39,0],[621,13,621,14,0],[622,17,622,89,0],[624,13,624,25,0],[625,9,625,10,0],[636,9,636,10,0],[637,13,637,62,0],[638,13,638,31,0],[639,13,639,31,0],[640,13,640,14,0],[641,17,641,64,0],[644,13,644,129,0],[645,13,645,38,0],[646,13,646,43,0],[647,13,647,30,0],[648,13,648,14,0],[649,17,649,48,0],[649,48,649,66,0],[649,66,649,123,0],[649,123,649,124,0],[649,48,649,124,0],[649,124,650,35,0],[650,35,650,41,0],[650,41,650,43,0],[649,17,650,43,0],[652,17,652,24,0],[652,26,652,36,0],[652,37,652,39,0],[652,40,652,47,0],[653,17,653,18,0],[654,21,654,79,0],[655,21,655,38,0],[656,21,656,22,0],[657,25,657,41,0],[658,21,658,22,0],[659,17,659,18,0],[660,13,660,14,0],[661,13,661,26,0],[662,9,662,10,0],[673,9,673,10,0],[674,13,674,62,0],[675,13,675,31,0],[676,13,676,58,0],[677,13,677,14,0],[678,17,678,77,0],[681,13,681,83,0],[682,13,682,43,0],[684,13,684,30,0],[685,13,685,14,0],[686,17,686,134,0],[687,17,687,42,0],[688,17,688,34,0],[689,17,689,18,0],[690,21,690,28,0],[690,29,690,42,0],[690,43,690,45,0],[690,46,690,50,0],[691,21,691,22,0],[692,25,692,90,0],[693,25,693,42,0],[694,25,694,26,0],[695,29,695,45,0],[696,25,696,26,0],[697,21,697,22,0],[698,17,698,18,0],[699,13,699,14,0],[700,13,700,26,0],[701,9,701,10,0],[712,9,712,10,1],[713,13,713,121,1],[714,13,714,39,1],[715,13,715,14,1],[716,17,716,29,1],[719,13,719,113,0],[720,13,720,42,0],[721,13,721,30,0],[722,13,722,14,0],[723,17,723,55,0],[724,13,724,14,0],[726,13,726,25,0],[727,9,727,10,1],[737,9,737,10,0],[738,13,738,115,0],[740,13,740,34,0],[741,9,741,10,0],[750,9,750,10,0],[751,13,751,72,0],[752,9,752,10,0],[763,9,763,10,0],[764,13,764,121,0],[765,13,765,38,0],[766,13,766,30,0],[767,13,767,14,0],[768,17,768,58,0],[768,58,768,138,0],[768,138,768,140,0],[768,17,768,140,0],[770,13,770,25,0],[771,9,771,10,0],[781,9,781,10,0],[782,13,782,132,0],[783,13,783,38,0],[784,13,784,30,0],[785,13,785,14,0],[786,17,786,102,0],[788,13,788,25,0],[789,9,789,10,0],[800,9,800,10,0],[801,13,801,138,0],[802,13,802,39,0],[803,13,803,14,0],[804,17,805,34,0],[805,34,811,22,0],[811,22,812,33,0],[812,33,812,83,0],[812,83,813,39,0],[804,17,813,39,0],[815,13,815,25,0],[816,9,816,10,0],[824,9,824,10,0],[825,13,825,110,0],[826,9,826,10,0],[835,9,835,10,0],[836,13,836,106,0],[837,9,837,10,0]]);
    </script>
  </body>
</html>