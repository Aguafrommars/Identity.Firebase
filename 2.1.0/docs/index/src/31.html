<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Aguacongas.Firebase;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore: UserOnlyStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, IdentityUserClaim&lt;string&gt;, IdentityUserLogin&lt;string&gt;, IdentityUserToken&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt; :
        FirebaseUserStoreBase&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;string&gt;
        where TUserClaim : IdentityUserClaim&lt;string&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;string&gt;, new()
        where TUserToken : IdentityUserToken&lt;string&gt;, new()
    {
        private const string UsersTableName = &quot;users&quot;;
        private const string UserLoginsTableName = &quot;user-logins&quot;;
        private const string UserClaimsTableName = &quot;user-claims&quot;;
        private const string UserTokensTableName = &quot;user-tokens&quot;;

        private readonly IFirebaseClient _client;

        /// &lt;summary&gt;
        /// A navigation property for the users the store contains.
        /// &lt;/summary&gt;
        public override IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var response = _client.GetAsync&lt;Dictionary&lt;string, object&gt;&gt;(GetFirebasePath(UsersTableName), queryString: &quot;shallow=true&quot;).GetAwaiter().GetResult();
                var userDictionary = response.Data;
                if (userDictionary == null)
                {
                    return new List&lt;TUser&gt;(0).AsQueryable();
                }

                var taskList = new List&lt;Task&lt;TUser&gt;&gt;();
                foreach(var key in userDictionary.Keys)
                {
                    taskList.Add(FindByIdAsync(key));
                }

                Task.WaitAll(taskList.ToArray());
                var users = taskList.Where(t =&gt; t.Result != null)
                    .Select(t =&gt; t.Result)
                    .ToList();

                return users.AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.PostAsync(GetFirebasePath(UsersTableName), user, cancellationToken);
            user.Id = response.Data;
            user.ConcurrencyStamp = response.Etag;
            
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync(GetFirebasePath(UsersTableName, user.Id), user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync(GetFirebasePath(UsersTableName, user.Id), cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;(GetFirebasePath(UsersTableName, userId), cancellationToken, true);
            var user = response.Data;
            if (user != null)
            {
                user.Id = userId;
                user.ConcurrencyStamp = response.Etag;
            }
            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach(var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
                
            }
            catch(FirebaseException e)
               when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
            }
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            
            if (data != null)
            {
                return data.Select(c =&gt; c.Value.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var taskList = new List&lt;Task&gt;(userClaims.Count);
            foreach(var userClaim in userClaims)
            {
                taskList.Add(_client.PostAsync(GetFirebasePath(UserClaimsTableName), userClaim, cancellationToken));
            }

            await Task.WhenAll(taskList.ToArray());
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            data = data ?? new Dictionary&lt;string, TUserClaim&gt;();
            foreach(var kv in data)
            {
                var uc = kv.Value;
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;

                    await _client.PutAsync(GetFirebasePath(UserClaimsTableName, kv.Key), uc, cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                var taskList = new List&lt;Task&gt;(claims.Count());
                foreach (var claim in claims)
                {
                    var match = data.SingleOrDefault(kv =&gt; kv.Value.ClaimType == claim.Type &amp;&amp; kv.Value.ClaimValue == claim.Value);
                    if (match.Key != null)
                    {
                        taskList.Add(_client.DeleteAsync(GetFirebasePath(UserClaimsTableName, match.Key), cancellationToken));
                    }
                }

                Task.WaitAll(taskList.ToArray());
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            await _client.PostAsync(GetFirebasePath(UserLoginsTableName), CreateUserLogin(user, login), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = await GetUserLoginsAsync(user.Id, cancellationToken);

            foreach (var kv in data)
            {
                var login = kv.Value;
                if (login.LoginProvider == loginProvider &amp;&amp; login.ProviderKey == providerKey)
                {
                    await _client.DeleteAsync(GetFirebasePath(UserLoginsTableName, kv.Key), cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values
                    .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                    .ToList();
            }
            return new List&lt;UserLoginInfo&gt;(0);
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }

            if (data == null)
            {
                return new List&lt;TUser&gt;(0);
            }

            var userIds = data.Values.Where(c =&gt; c.ClaimValue == claim.Value).Select(c =&gt; c.UserId);
            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(userIds.Count());
            foreach (var userId in userIds)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(string userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId, cancellationToken);
            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;List&lt;TUserToken&gt;&gt;(GetFirebasePath(UserTokensTableName, user.Id), cancellationToken);
            return response.Data ?? new List&lt;TUserToken&gt;();
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            await _client.PutAsync(GetFirebasePath(UserTokensTableName, user.Id), tokens, cancellationToken);
        }

        protected virtual async Task&lt;Dictionary&lt;string, TUserLogin&gt;&gt; GetUserLoginsAsync(string userId, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }

            return data;
        }


        protected virtual void SetIndex(Dictionary&lt;string, object&gt; rules, string key, object index)
        {
            rules[key] = index;
        }

        internal async Task SetIndex(string onTable, object index, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;FirebaseRules&gt;(RulePath, cancellationToken);
            var rules = response.Data ?? new FirebaseRules();
            SetIndex(rules.Rules, onTable, index);
            await _client.PutAsync(RulePath, rules, cancellationToken);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,97,24,120,1],[24,121,24,122,1],[24,123,24,124,1],[39,97,39,120,1],[39,121,39,122,1],[39,123,39,124,1],[80,13,80,14,1],[81,17,81,164,1],[82,17,82,52,1],[83,17,83,44,1],[84,17,84,18,0],[85,21,85,61,0],[88,17,88,56,1],[89,17,89,24,1],[89,25,89,32,1],[89,33,89,35,1],[89,36,89,55,1],[90,17,90,18,1],[91,21,91,54,1],[92,17,92,18,1],[94,17,94,50,1],[95,17,95,49,1],[95,49,95,65,1],[95,65,96,34,1],[96,34,96,42,1],[96,42,97,31,1],[95,17,97,31,1],[99,17,99,44,1],[100,13,100,14,1],[108,97,108,144,1],[109,9,109,10,1],[110,13,110,81,1],[111,9,111,10,1],[120,9,120,10,1],[121,13,121,62,1],[122,13,122,31,1],[123,13,123,30,1],[124,13,124,14,1],[125,17,125,63,1],[127,13,127,110,1],[128,13,128,37,1],[129,13,129,51,1],[131,13,131,43,1],[132,9,132,10,1],[141,9,141,10,1],[142,13,142,62,1],[143,13,143,31,1],[144,13,144,30,1],[145,13,145,14,1],[146,17,146,63,1],[150,13,150,14,1],[151,17,151,151,1],[152,17,152,55,1],[153,13,153,14,1],[155,17,155,73,0],[156,13,156,14,0],[157,17,157,83,0],[160,13,160,43,1],[161,9,161,10,1],[170,9,170,10,1],[171,13,171,62,1],[172,13,172,31,1],[173,13,173,30,1],[174,13,174,14,1],[175,17,175,63,1],[179,13,179,14,1],[180,17,180,133,1],[181,13,181,14,1],[183,17,183,73,0],[184,13,184,14,0],[185,17,185,83,0],[187,13,187,43,1],[188,9,188,10,1],[199,9,199,10,1],[200,13,200,62,1],[201,13,201,31,1],[202,13,202,124,1],[203,13,203,38,1],[204,13,204,30,1],[205,13,205,14,1],[206,17,206,34,1],[207,17,207,55,1],[208,13,208,14,1],[209,13,209,25,1],[210,9,210,10,1],[221,9,221,10,1],[222,13,222,62,1],[223,13,223,31,1],[225,13,225,14,1],[226,17,226,209,1],[227,17,227,24,1],[227,25,227,31,1],[227,32,227,34,1],[227,35,227,48,1],[228,17,228,18,1],[229,21,229,75,1],[231,17,231,29,1],[235,16,235,91,1],[236,13,236,14,1],[237,17,237,84,1],[239,17,239,209,1],[240,17,240,24,1],[240,26,240,32,0],[240,33,240,35,1],[240,36,240,49,1],[241,17,241,18,0],[242,21,242,75,0],[244,17,244,29,1],[246,9,246,10,1],[255,9,255,10,1],[256,13,256,62,1],[257,13,257,31,1],[258,13,258,30,1],[259,13,259,14,1],[260,17,260,63,1],[265,13,265,14,1],[266,17,266,196,1],[267,17,267,38,1],[268,13,268,14,1],[270,17,270,92,1],[271,13,271,14,1],[272,17,272,94,1],[274,17,274,202,1],[275,17,275,38,1],[276,13,276,14,1],[278,13,278,30,1],[279,13,279,14,1],[280,17,280,41,1],[280,41,280,58,1],[280,58,280,69,1],[280,17,280,69,1],[282,13,282,39,0],[283,9,283,10,1],[293,9,293,10,1],[294,13,294,62,1],[295,13,295,31,1],[296,13,296,30,1],[297,13,297,14,1],[298,17,298,63,1],[300,13,300,32,1],[301,13,301,14,1],[302,17,302,65,1],[305,13,305,62,1],[305,62,305,86,1],[305,86,305,97,1],[305,13,305,97,1],[306,13,306,61,1],[307,13,307,20,1],[307,21,307,34,1],[307,35,307,37,1],[307,38,307,48,1],[308,13,308,14,1],[309,17,309,117,1],[310,13,310,14,1],[312,13,312,52,1],[313,9,313,10,1],[324,9,324,10,1],[325,13,325,62,1],[326,13,326,31,1],[327,13,327,30,1],[328,13,328,14,1],[329,17,329,63,1],[331,13,331,31,1],[332,13,332,14,0],[333,17,333,64,0],[335,13,335,34,1],[336,13,336,14,0],[337,17,337,67,0],[342,13,342,14,1],[343,17,343,196,1],[344,17,344,38,1],[345,13,345,14,1],[347,17,347,92,0],[348,13,348,14,0],[349,17,349,94,0],[351,17,351,202,0],[352,17,352,38,0],[353,13,353,14,0],[355,13,355,65,1],[356,13,356,20,1],[356,21,356,27,1],[356,28,356,30,1],[356,31,356,35,1],[357,13,357,14,1],[358,17,358,35,1],[359,17,359,80,1],[360,17,360,18,1],[361,21,361,50,1],[362,21,362,52,1],[364,21,364,113,1],[365,17,365,18,1],[366,13,366,14,1],[367,9,367,10,1],[377,9,377,10,1],[378,13,378,31,1],[379,13,379,30,1],[380,13,380,14,1],[381,17,381,63,1],[383,13,383,32,1],[384,13,384,14,1],[385,17,385,65,1],[390,13,390,14,1],[391,17,391,196,1],[392,17,392,38,1],[393,13,393,14,1],[395,17,395,92,0],[396,13,396,14,0],[397,17,397,94,0],[399,17,399,202,0],[400,17,400,38,0],[401,13,401,14,0],[403,13,403,30,1],[404,13,404,14,1],[405,17,405,63,1],[406,17,406,24,1],[406,26,406,35,1],[406,36,406,38,1],[406,39,406,45,1],[407,17,407,18,1],[408,21,408,60,1],[408,60,408,130,1],[408,130,408,132,1],[408,21,408,132,1],[409,21,409,43,1],[410,21,410,22,1],[411,25,411,127,1],[412,21,412,22,1],[413,17,413,18,1],[415,17,415,50,1],[416,13,416,14,1],[417,9,417,10,1],[428,9,428,10,1],[429,13,429,62,1],[430,13,430,31,1],[431,13,431,30,1],[432,13,432,14,1],[433,17,433,63,1],[435,13,435,31,1],[436,13,436,14,1],[437,17,437,64,1],[440,13,440,124,1],[441,9,441,10,1],[453,9,453,10,1],[454,13,454,62,1],[455,13,455,31,1],[456,13,456,30,1],[457,13,457,14,1],[458,17,458,63,1],[461,13,461,77,1],[463,13,463,20,1],[463,22,463,28,1],[463,29,463,31,1],[463,32,463,36,1],[464,13,464,14,1],[465,17,465,38,1],[466,17,466,94,1],[467,17,467,18,1],[468,21,468,112,1],[469,17,469,18,1],[470,13,470,14,1],[471,9,471,10,1],[482,9,482,10,1],[483,13,483,62,1],[484,13,484,31,1],[485,13,485,30,1],[486,13,486,14,1],[487,17,487,63,1],[492,13,492,14,1],[493,17,493,196,1],[494,17,494,38,1],[495,13,495,14,1],[497,17,497,92,1],[498,13,498,14,1],[499,17,499,90,1],[501,17,501,202,1],[502,17,502,38,1],[503,13,503,14,1],[505,13,505,30,1],[506,13,506,14,1],[507,17,508,34,1],[508,34,508,106,1],[508,106,509,31,1],[507,17,509,31,1],[511,13,511,47,0],[512,9,512,10,1],[525,9,525,10,1],[526,13,526,62,1],[527,13,527,31,1],[528,13,528,101,1],[529,13,529,35,1],[530,13,530,14,1],[531,17,531,81,1],[533,13,533,25,1],[534,9,534,10,1],[545,9,545,10,1],[546,13,546,62,1],[547,13,547,31,1],[550,13,550,14,1],[551,17,551,203,1],[552,17,552,24,1],[552,26,552,32,1],[552,33,552,35,1],[552,36,552,49,1],[553,17,553,18,1],[554,21,554,75,1],[556,17,556,29,1],[560,17,560,92,0],[561,13,561,14,0],[562,17,562,84,0],[564,17,564,203,0],[565,17,565,24,0],[565,26,565,32,0],[565,33,565,35,0],[565,36,565,49,0],[566,17,566,18,0],[567,21,567,75,0],[569,17,569,29,0],[572,9,572,10,1],[583,9,583,10,1],[584,13,584,62,1],[585,13,585,31,1],[586,13,586,31,1],[587,13,587,14,0],[588,17,588,64,0],[593,13,593,14,1],[594,17,594,202,1],[595,17,595,38,1],[596,13,596,14,1],[598,17,598,92,0],[599,13,599,14,0],[600,17,600,94,0],[602,17,602,208,0],[603,17,603,38,0],[604,13,604,14,0],[606,13,606,30,1],[607,13,607,14,0],[608,17,608,43,0],[611,13,611,50,1],[611,50,611,77,1],[611,77,611,91,1],[611,91,611,99,1],[611,99,611,101,1],[611,13,611,101,1],[612,13,612,52,1],[613,13,613,60,1],[614,13,614,20,1],[614,22,614,32,1],[614,33,614,35,1],[614,36,614,43,1],[615,13,615,14,1],[616,17,616,51,1],[616,51,616,52,1],[616,52,617,21,1],[617,21,617,79,1],[617,79,618,21,1],[618,21,618,38,1],[618,38,619,21,1],[619,21,619,22,1],[619,22,620,25,1],[620,25,620,41,1],[620,41,621,21,1],[621,21,621,22,1],[621,22,622,17,1],[622,17,622,18,1],[622,18,622,21,1],[616,17,622,21,1],[623,13,623,14,1],[625,13,625,46,1],[627,13,627,35,1],[628,9,628,10,1],[639,9,639,10,0],[640,13,640,94,0],[641,9,641,10,0],[651,9,651,10,0],[652,13,652,86,0],[653,9,653,10,0],[662,9,662,10,1],[663,13,663,64,1],[664,9,664,10,1],[674,9,674,10,1],[675,13,675,73,1],[676,9,676,10,1],[685,9,685,10,1],[686,13,686,72,1],[687,9,687,10,1],[698,9,698,10,0],[699,13,699,76,0],[700,13,700,30,0],[701,13,701,14,0],[702,17,702,56,0],[702,56,702,120,0],[702,120,702,122,0],[702,17,702,122,0],[704,13,704,25,0],[705,9,705,10,0],[715,9,715,10,1],[718,13,718,14,1],[719,17,719,205,1],[720,17,720,38,1],[721,13,721,14,1],[723,17,723,92,1],[724,13,724,14,1],[725,17,725,90,1],[727,17,727,211,1],[728,17,728,38,1],[729,13,729,14,1],[731,13,731,30,1],[732,13,732,14,1],[733,17,733,56,1],[733,56,733,120,1],[733,120,733,122,1],[733,17,733,122,1],[735,13,735,25,0],[736,9,736,10,1],[745,9,745,10,1],[746,13,746,135,1],[747,13,747,60,1],[748,9,748,10,1],[758,9,758,10,1],[759,13,759,110,1],[760,9,760,10,1],[763,9,763,10,1],[766,13,766,14,1],[767,17,767,195,1],[768,17,768,38,1],[769,13,769,14,1],[771,17,771,92,0],[772,13,772,14,0],[773,17,773,90,0],[775,17,775,201,0],[776,17,776,38,0],[777,13,777,14,0],[779,13,779,25,1],[780,9,780,10,1],[784,9,784,10,1],[785,13,785,32,1],[786,9,786,10,1],[789,9,789,10,1],[790,13,790,95,1],[791,13,791,62,1],[792,13,792,51,1],[793,13,793,72,1],[794,9,794,10,1]]);
    </script>
  </body>
</html>