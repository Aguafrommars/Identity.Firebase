<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Aguacongas.Firebase;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore: UserOnlyStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, IdentityUserClaim&lt;string&gt;, IdentityUserLogin&lt;string&gt;, IdentityUserToken&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt; :
        FirebaseUserStoreBase&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;string&gt;
        where TUserClaim : IdentityUserClaim&lt;string&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;string&gt;, new()
        where TUserToken : IdentityUserToken&lt;string&gt;, new()
    {
        private const string UsersTableName = &quot;users&quot;;
        private const string UserLoginsTableName = &quot;user-logins&quot;;
        private const string UserClaimsTableName = &quot;user-claims&quot;;
        private const string UserTokensTableName = &quot;user-tokens&quot;;

        private readonly IFirebaseClient _client;

        /// &lt;summary&gt;
        /// A navigation property for the users the store contains.
        /// &lt;/summary&gt;
        public override IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var response = _client.GetAsync&lt;Dictionary&lt;string, object&gt;&gt;(GetFirebasePath(UsersTableName), queryString: &quot;shallow=true&quot;).GetAwaiter().GetResult();
                var userDictionary = response.Data;
                if (userDictionary == null)
                {
                    return new List&lt;TUser&gt;().AsQueryable();
                }

                var taskList = new List&lt;Task&lt;TUser&gt;&gt;();
                foreach(var key in userDictionary.Keys)
                {
                    taskList.Add(FindByIdAsync(key));
                }

                var results = Task.WhenAll(taskList).GetAwaiter().GetResult();

                return results.Where(u =&gt; u != null).AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.PostAsync(GetFirebasePath(UsersTableName), user, cancellationToken);
            user.Id = response.Data;
            user.ConcurrencyStamp = response.Etag;
            
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync(GetFirebasePath(UsersTableName, user.Id), user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync(GetFirebasePath(UsersTableName, user.Id), cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;(GetFirebasePath(UsersTableName, userId), cancellationToken, true);
            var user = response.Data;
            if (user != null)
            {
                user.Id = userId;
                user.ConcurrencyStamp = response.Etag;
            }
            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach(var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
                
            }
            catch(FirebaseException e)
               when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
            }
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            
            if (data != null)
            {
                return data.Select(c =&gt; c.Value.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var taskList = new List&lt;Task&gt;(userClaims.Count);
            foreach(var userClaim in userClaims)
            {
                taskList.Add(_client.PostAsync(GetFirebasePath(UserClaimsTableName), userClaim, cancellationToken));
            }

            await Task.WhenAll(taskList.ToArray());
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            data = data ?? new Dictionary&lt;string, TUserClaim&gt;();
            foreach(var kv in data)
            {
                var uc = kv.Value;
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;

                    await _client.PutAsync(GetFirebasePath(UserClaimsTableName, kv.Key), uc, cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                var taskList = new List&lt;Task&gt;(claims.Count());
                foreach (var claim in claims)
                {
                    var match = data.SingleOrDefault(kv =&gt; kv.Value.ClaimType == claim.Type &amp;&amp; kv.Value.ClaimValue == claim.Value);
                    if (match.Key != null)
                    {
                        taskList.Add(_client.DeleteAsync(GetFirebasePath(UserClaimsTableName, match.Key), cancellationToken));
                    }
                }

                Task.WaitAll(taskList.ToArray());
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            await _client.PostAsync(GetFirebasePath(UserLoginsTableName), CreateUserLogin(user, login), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = await GetUserLoginsAsync(user.Id, cancellationToken);

            foreach (var kv in data)
            {
                var login = kv.Value;
                if (login.LoginProvider == loginProvider &amp;&amp; login.ProviderKey == providerKey)
                {
                    await _client.DeleteAsync(GetFirebasePath(UserLoginsTableName, kv.Key), cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values
                    .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                    .ToList();
            }
            return new List&lt;UserLoginInfo&gt;(0);
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }

            if (data == null)
            {
                return new List&lt;TUser&gt;(0);
            }

            var userIds = data.Values.Where(c =&gt; c.ClaimValue == claim.Value).Select(c =&gt; c.UserId);
            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(userIds.Count());
            foreach (var userId in userIds)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(string userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId, cancellationToken);
            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;List&lt;TUserToken&gt;&gt;(GetFirebasePath(UserTokensTableName, user.Id), cancellationToken);
            return response.Data ?? new List&lt;TUserToken&gt;();
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            await _client.PutAsync(GetFirebasePath(UserTokensTableName, user.Id), tokens, cancellationToken);
        }

        protected virtual async Task&lt;Dictionary&lt;string, TUserLogin&gt;&gt; GetUserLoginsAsync(string userId, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }

            return data;
        }


        protected virtual void SetIndex(Dictionary&lt;string, object&gt; rules, string key, object index)
        {
            rules[key] = index;
        }

        internal async Task SetIndex(string onTable, object index, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;FirebaseRules&gt;(RulePath, cancellationToken);
            var rules = response.Data ?? new FirebaseRules();
            SetIndex(rules.Rules, onTable, index);
            await _client.PutAsync(RulePath, rules, cancellationToken);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,97,24,120,1],[24,121,24,122,1],[24,123,24,124,1],[39,97,39,120,1],[39,121,39,122,1],[39,123,39,124,1],[80,13,80,14,1],[81,17,81,164,1],[82,17,82,52,1],[83,17,83,44,1],[84,17,84,18,0],[85,21,85,60,0],[88,17,88,56,1],[89,17,89,24,1],[89,25,89,32,1],[89,33,89,35,1],[89,36,89,55,1],[90,17,90,18,1],[91,21,91,54,1],[92,17,92,18,1],[94,17,94,79,1],[96,17,96,43,1],[96,43,96,52,1],[96,52,96,68,1],[96,17,96,68,1],[97,13,97,14,1],[105,97,105,144,1],[106,9,106,10,1],[107,13,107,81,1],[108,9,108,10,1],[117,9,117,10,1],[118,13,118,62,1],[119,13,119,31,1],[120,13,120,30,1],[121,13,121,14,1],[122,17,122,63,1],[124,13,124,110,1],[125,13,125,37,1],[126,13,126,51,1],[128,13,128,43,1],[129,9,129,10,1],[138,9,138,10,1],[139,13,139,62,1],[140,13,140,31,1],[141,13,141,30,1],[142,13,142,14,1],[143,17,143,63,1],[147,13,147,14,1],[148,17,148,151,1],[149,17,149,55,1],[150,13,150,14,1],[152,17,152,73,0],[153,13,153,14,0],[154,17,154,83,0],[157,13,157,43,1],[158,9,158,10,1],[167,9,167,10,1],[168,13,168,62,1],[169,13,169,31,1],[170,13,170,30,1],[171,13,171,14,1],[172,17,172,63,1],[176,13,176,14,1],[177,17,177,133,1],[178,13,178,14,1],[180,17,180,73,0],[181,13,181,14,0],[182,17,182,83,0],[184,13,184,43,1],[185,9,185,10,1],[196,9,196,10,1],[197,13,197,62,1],[198,13,198,31,1],[199,13,199,124,1],[200,13,200,38,1],[201,13,201,30,1],[202,13,202,14,1],[203,17,203,34,1],[204,17,204,55,1],[205,13,205,14,1],[206,13,206,25,1],[207,9,207,10,1],[218,9,218,10,1],[219,13,219,62,1],[220,13,220,31,1],[222,13,222,14,1],[223,17,223,209,1],[224,17,224,24,1],[224,25,224,31,1],[224,32,224,34,1],[224,35,224,48,1],[225,17,225,18,1],[226,21,226,75,1],[228,17,228,29,1],[232,16,232,91,1],[233,13,233,14,1],[234,17,234,84,1],[236,17,236,209,1],[237,17,237,24,1],[237,26,237,32,0],[237,33,237,35,1],[237,36,237,49,1],[238,17,238,18,0],[239,21,239,75,0],[241,17,241,29,1],[243,9,243,10,1],[252,9,252,10,1],[253,13,253,62,1],[254,13,254,31,1],[255,13,255,30,1],[256,13,256,14,1],[257,17,257,63,1],[262,13,262,14,1],[263,17,263,196,1],[264,17,264,38,1],[265,13,265,14,1],[267,17,267,92,1],[268,13,268,14,1],[269,17,269,94,1],[271,17,271,202,1],[272,17,272,38,1],[273,13,273,14,1],[275,13,275,30,1],[276,13,276,14,1],[277,17,277,41,1],[277,41,277,58,1],[277,58,277,69,1],[277,17,277,69,1],[279,13,279,39,0],[280,9,280,10,1],[290,9,290,10,1],[291,13,291,62,1],[292,13,292,31,1],[293,13,293,30,1],[294,13,294,14,1],[295,17,295,63,1],[297,13,297,32,1],[298,13,298,14,1],[299,17,299,65,1],[302,13,302,62,1],[302,62,302,86,1],[302,86,302,97,1],[302,13,302,97,1],[303,13,303,61,1],[304,13,304,20,1],[304,21,304,34,1],[304,35,304,37,1],[304,38,304,48,1],[305,13,305,14,1],[306,17,306,117,1],[307,13,307,14,1],[309,13,309,52,1],[310,9,310,10,1],[321,9,321,10,1],[322,13,322,62,1],[323,13,323,31,1],[324,13,324,30,1],[325,13,325,14,1],[326,17,326,63,1],[328,13,328,31,1],[329,13,329,14,0],[330,17,330,64,0],[332,13,332,34,1],[333,13,333,14,0],[334,17,334,67,0],[339,13,339,14,1],[340,17,340,196,1],[341,17,341,38,1],[342,13,342,14,1],[344,17,344,92,0],[345,13,345,14,0],[346,17,346,94,0],[348,17,348,202,0],[349,17,349,38,0],[350,13,350,14,0],[352,13,352,65,1],[353,13,353,20,1],[353,21,353,27,1],[353,28,353,30,1],[353,31,353,35,1],[354,13,354,14,1],[355,17,355,35,1],[356,17,356,80,1],[357,17,357,18,1],[358,21,358,50,1],[359,21,359,52,1],[361,21,361,113,1],[362,17,362,18,1],[363,13,363,14,1],[364,9,364,10,1],[374,9,374,10,1],[375,13,375,31,1],[376,13,376,30,1],[377,13,377,14,1],[378,17,378,63,1],[380,13,380,32,1],[381,13,381,14,1],[382,17,382,65,1],[387,13,387,14,1],[388,17,388,196,1],[389,17,389,38,1],[390,13,390,14,1],[392,17,392,92,0],[393,13,393,14,0],[394,17,394,94,0],[396,17,396,202,0],[397,17,397,38,0],[398,13,398,14,0],[400,13,400,30,1],[401,13,401,14,1],[402,17,402,63,1],[403,17,403,24,1],[403,26,403,35,1],[403,36,403,38,1],[403,39,403,45,1],[404,17,404,18,1],[405,21,405,60,1],[405,60,405,130,1],[405,130,405,132,1],[405,21,405,132,1],[406,21,406,43,1],[407,21,407,22,1],[408,25,408,127,1],[409,21,409,22,1],[410,17,410,18,1],[412,17,412,50,1],[413,13,413,14,1],[414,9,414,10,1],[425,9,425,10,1],[426,13,426,62,1],[427,13,427,31,1],[428,13,428,30,1],[429,13,429,14,1],[430,17,430,63,1],[432,13,432,31,1],[433,13,433,14,1],[434,17,434,64,1],[437,13,437,124,1],[438,9,438,10,1],[450,9,450,10,1],[451,13,451,62,1],[452,13,452,31,1],[453,13,453,30,1],[454,13,454,14,1],[455,17,455,63,1],[458,13,458,77,1],[460,13,460,20,1],[460,22,460,28,1],[460,29,460,31,1],[460,32,460,36,1],[461,13,461,14,1],[462,17,462,38,1],[463,17,463,94,1],[464,17,464,18,1],[465,21,465,112,1],[466,17,466,18,1],[467,13,467,14,1],[468,9,468,10,1],[479,9,479,10,1],[480,13,480,62,1],[481,13,481,31,1],[482,13,482,30,1],[483,13,483,14,1],[484,17,484,63,1],[489,13,489,14,1],[490,17,490,196,1],[491,17,491,38,1],[492,13,492,14,1],[494,17,494,92,1],[495,13,495,14,1],[496,17,496,90,1],[498,17,498,202,1],[499,17,499,38,1],[500,13,500,14,1],[502,13,502,30,1],[503,13,503,14,1],[504,17,505,34,1],[505,34,505,106,1],[505,106,506,31,1],[504,17,506,31,1],[508,13,508,47,0],[509,9,509,10,1],[522,9,522,10,1],[523,13,523,62,1],[524,13,524,31,1],[525,13,525,101,1],[526,13,526,35,1],[527,13,527,14,1],[528,17,528,81,1],[530,13,530,25,1],[531,9,531,10,1],[542,9,542,10,1],[543,13,543,62,1],[544,13,544,31,1],[547,13,547,14,1],[548,17,548,203,1],[549,17,549,24,1],[549,26,549,32,1],[549,33,549,35,1],[549,36,549,49,1],[550,17,550,18,1],[551,21,551,75,1],[553,17,553,29,1],[557,17,557,92,0],[558,13,558,14,0],[559,17,559,84,0],[561,17,561,203,0],[562,17,562,24,0],[562,26,562,32,0],[562,33,562,35,0],[562,36,562,49,0],[563,17,563,18,0],[564,21,564,75,0],[566,17,566,29,0],[569,9,569,10,1],[580,9,580,10,1],[581,13,581,62,1],[582,13,582,31,1],[583,13,583,31,1],[584,13,584,14,0],[585,17,585,64,0],[590,13,590,14,1],[591,17,591,202,1],[592,17,592,38,1],[593,13,593,14,1],[595,17,595,92,0],[596,13,596,14,0],[597,17,597,94,0],[599,17,599,208,0],[600,17,600,38,0],[601,13,601,14,0],[603,13,603,30,1],[604,13,604,14,0],[605,17,605,43,0],[608,13,608,50,1],[608,50,608,77,1],[608,77,608,91,1],[608,91,608,99,1],[608,99,608,101,1],[608,13,608,101,1],[609,13,609,52,1],[610,13,610,60,1],[611,13,611,20,1],[611,22,611,32,1],[611,33,611,35,1],[611,36,611,43,1],[612,13,612,14,1],[613,17,613,51,1],[613,51,613,52,1],[613,52,614,21,1],[614,21,614,79,1],[614,79,615,21,1],[615,21,615,38,1],[615,38,616,21,1],[616,21,616,22,1],[616,22,617,25,1],[617,25,617,41,1],[617,41,618,21,1],[618,21,618,22,1],[618,22,619,17,1],[619,17,619,18,1],[619,18,619,21,1],[613,17,619,21,1],[620,13,620,14,1],[622,13,622,46,1],[624,13,624,35,1],[625,9,625,10,1],[636,9,636,10,0],[637,13,637,94,0],[638,9,638,10,0],[648,9,648,10,0],[649,13,649,86,0],[650,9,650,10,0],[659,9,659,10,1],[660,13,660,64,1],[661,9,661,10,1],[671,9,671,10,1],[672,13,672,73,1],[673,9,673,10,1],[682,9,682,10,1],[683,13,683,72,1],[684,9,684,10,1],[695,9,695,10,0],[696,13,696,76,0],[697,13,697,30,0],[698,13,698,14,0],[699,17,699,56,0],[699,56,699,120,0],[699,120,699,122,0],[699,17,699,122,0],[701,13,701,25,0],[702,9,702,10,0],[712,9,712,10,1],[715,13,715,14,1],[716,17,716,205,1],[717,17,717,38,1],[718,13,718,14,1],[720,17,720,92,1],[721,13,721,14,1],[722,17,722,90,1],[724,17,724,211,1],[725,17,725,38,1],[726,13,726,14,1],[728,13,728,30,1],[729,13,729,14,1],[730,17,730,56,1],[730,56,730,120,1],[730,120,730,122,1],[730,17,730,122,1],[732,13,732,25,0],[733,9,733,10,1],[742,9,742,10,1],[743,13,743,135,1],[744,13,744,60,1],[745,9,745,10,1],[755,9,755,10,1],[756,13,756,110,1],[757,9,757,10,1],[760,9,760,10,1],[763,13,763,14,1],[764,17,764,195,1],[765,17,765,38,1],[766,13,766,14,1],[768,17,768,92,0],[769,13,769,14,0],[770,17,770,90,0],[772,17,772,201,0],[773,17,773,38,0],[774,13,774,14,0],[776,13,776,25,1],[777,9,777,10,1],[781,9,781,10,1],[782,13,782,32,1],[783,9,783,10,1],[786,9,786,10,1],[787,13,787,95,1],[788,13,788,62,1],[789,13,789,51,1],[790,13,790,72,1],[791,9,791,10,1]]);
    </script>
  </body>
</html>