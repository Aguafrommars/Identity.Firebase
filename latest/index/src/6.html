<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firestore\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Google.Cloud.Firestore;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firestore
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore : UserOnlyStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;FirestoreDb&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(FirestoreDb db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, IdentityUserClaim&lt;string&gt;, IdentityUserLogin&lt;string&gt;, IdentityUserToken&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;, new()
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;FirestoreDb&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(FirestoreDb db, IdentityErrorDescriber describer = null) : base(db, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt; :
        FirestoreUserStoreBase&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;string&gt;, new()
        where TUserClaim : IdentityUserClaim&lt;string&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;string&gt;, new()
        where TUserToken : IdentityUserToken&lt;string&gt;, new()
    {
        private const string UsersTableName = &quot;users&quot;;
        private const string UserLoginsTableName = &quot;user-logins&quot;;
        private const string UserClaimsTableName = &quot;user-claims&quot;;
        private const string UserTokensTableName = &quot;user-tokens&quot;;

        private readonly FirestoreDb _db;
        private readonly CollectionReference _users;
        private readonly CollectionReference _usersLogins;
        private readonly CollectionReference _usersClaims;
        private readonly CollectionReference _usersTokens;

        /// &lt;summary&gt;
        /// A navigation property for the users the store contains.
        /// &lt;/summary&gt;
        public override IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var documents = _users.GetSnapshotAsync().GetAwaiter().GetResult();
                return documents.Select(d =&gt; Map.FromDictionary&lt;TUser&gt;(d.ToDictionary())).AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;db&quot;&gt;The &lt;see cref=&quot;FirestoreDb&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(FirestoreDb db, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _db = db ?? throw new ArgumentNullException(nameof(db));
            _users = db.Collection(UsersTableName);
            _usersLogins = db.Collection(UserLoginsTableName);
            _usersClaims = db.Collection(UserClaimsTableName);
            _usersTokens = db.Collection(UserTokensTableName);
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var dictionary = Map.ToDictionary(user);
            var response = await _users.Document(user.Id).SetAsync(dictionary, cancellationToken: cancellationToken);

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var dictionary = Map.ToDictionary(user);
            return await _db.RunTransactionAsync(async transaction =&gt;
               {
                   var userRef = _users.Document(user.Id);
                   var snapShot = await transaction.GetSnapshotAsync(userRef, cancellationToken);
                   if (snapShot.GetValue&lt;string&gt;(&quot;ConcurrencyStamp&quot;) != user.ConcurrencyStamp)
                   {
                       return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
                   }
                   transaction.Update(userRef, dictionary);
                   return IdentityResult.Success;
               }, cancellationToken: cancellationToken);
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            return await _db.RunTransactionAsync(async transaction =&gt;
            {
                var userRef = _users.Document(user.Id);
                var snapShot = await transaction.GetSnapshotAsync(userRef, cancellationToken);
                if (snapShot.GetValue&lt;string&gt;(&quot;ConcurrencyStamp&quot;) != user.ConcurrencyStamp)
                {
                    return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
                }
                transaction.Delete(userRef);
                return IdentityResult.Success;
            }, cancellationToken: cancellationToken);
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (string.IsNullOrWhiteSpace(userId))
            {
                throw new ArgumentNullException(nameof(userId));
            }

            var snapShot = await _users.Document(userId).GetSnapshotAsync(cancellationToken);
            if (snapShot != null)
            {
                return Map.FromDictionary&lt;TUser&gt;(snapShot.ToDictionary());
            }

            return null;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (string.IsNullOrWhiteSpace(normalizedUserName))
            {
                throw new ArgumentNullException(nameof(normalizedUserName));
            }

            var snapShot = await _users.WhereEqualTo(&quot;NormalizedUserName&quot;, normalizedUserName)
                .GetSnapshotAsync(cancellationToken);
            var document = snapShot.Documents
                .FirstOrDefault();
            if (document != null)
            {
                return Map.FromDictionary&lt;TUser&gt;(document.ToDictionary());
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var snapShot = await _usersClaims.WhereEqualTo(&quot;UserId&quot;, user.Id)
                .GetSnapshotAsync(cancellationToken);
            return snapShot.Documents
                .Select(d =&gt; new Claim(d.GetValue&lt;string&gt;(&quot;Type&quot;), d.GetValue&lt;string&gt;(&quot;Value&quot;)))
                .ToList();
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            foreach (var claim in claims)
            {
                Dictionary&lt;string, object&gt; dictionary = ClaimsToDictionary(user, claim);
                await _usersClaims.AddAsync(dictionary, cancellationToken);
            }
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            await _db.RunTransactionAsync(async transaction =&gt;
            {
                var snapShot = await _usersClaims.WhereEqualTo(&quot;UserId&quot;, user.Id)
                    .WhereEqualTo(&quot;Type&quot;, claim.Type)
                    .GetSnapshotAsync(cancellationToken);
                var document = snapShot.Documents.First();
                transaction.Update(document.Reference, ClaimsToDictionary(user, newClaim));
            }, cancellationToken: cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            await _db.RunTransactionAsync(async transaction =&gt;
            {
                foreach(var claim in claims)
                {
                    var snapShot = await _usersClaims.WhereEqualTo(&quot;UserId&quot;, user.Id)
                        .WhereEqualTo(&quot;Type&quot;, claim.Type)
                        .GetSnapshotAsync(cancellationToken);
                    var document = snapShot.Documents.First();
                    transaction.Delete(document.Reference);
                }
            }, cancellationToken: cancellationToken);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            var dictionary = new Dictionary&lt;string, object&gt;
            {
                { &quot;UserId&quot;, user.Id },
                { &quot;LoginProvider&quot;, login.LoginProvider },
                { &quot;ProviderKey&quot;, login.ProviderKey },
                { &quot;ProviderDisplayName&quot;, login.ProviderDisplayName }
            };
            await _usersLogins.AddAsync(dictionary, cancellationToken); ;
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (string.IsNullOrWhiteSpace(loginProvider))
            {
                throw new ArgumentNullException(nameof(loginProvider));
            }
            if (string.IsNullOrWhiteSpace(providerKey))
            {
                throw new ArgumentNullException(nameof(providerKey));
            }

            await _db.RunTransactionAsync(async transaction =&gt;
            {
                var snapShot = await _usersLogins.WhereEqualTo(&quot;UserId&quot;, user.Id)
                    .WhereEqualTo(&quot;LoginProvider&quot;, loginProvider)
                    .WhereEqualTo(&quot;ProviderKey&quot;, providerKey)
                    .GetSnapshotAsync(cancellationToken);
                var document = snapShot.Documents.First();
                transaction.Delete(document.Reference);
            }, cancellationToken: cancellationToken);
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var snapShot = await _usersLogins.WhereEqualTo(&quot;UserId&quot;, user.Id)
                .GetSnapshotAsync(cancellationToken);
            var documents = snapShot.Documents;
            var list = new List&lt;UserLoginInfo&gt;(documents.Count);
            foreach(var doc in documents)
            {
                list.Add(new UserLoginInfo(doc.GetValue&lt;string&gt;(&quot;LoginProvider&quot;),
                    doc.GetValue&lt;string&gt;(&quot;ProviderKey&quot;),
                    doc.GetValue&lt;string&gt;(&quot;ProviderDisplayName&quot;)));
            }
            return list;
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (string.IsNullOrWhiteSpace(loginProvider))
            {
                throw new ArgumentNullException(nameof(loginProvider));
            }
            if (string.IsNullOrWhiteSpace(providerKey))
            {
                throw new ArgumentNullException(nameof(providerKey));
            }

            var snapShot = await _usersLogins.WhereEqualTo(&quot;LoginProvider&quot;, loginProvider)
                .WhereEqualTo(&quot;ProviderKey&quot;, providerKey)
                .GetSnapshotAsync(cancellationToken);
            var document = snapShot.Documents.FirstOrDefault();
            if (document != null)
            {
                var userId = document.GetValue&lt;string&gt;(&quot;UserId&quot;);
                return await FindByIdAsync(userId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (string.IsNullOrWhiteSpace(normalizedEmail))
            {
                throw new ArgumentNullException(nameof(normalizedEmail));
            }
            var snapShot = await _users.WhereEqualTo(&quot;NormalizedEmail&quot;, normalizedEmail)
                .GetSnapshotAsync(cancellationToken);
            var document = snapShot.Documents.FirstOrDefault();
            if (document != null)
            {
                return Map.FromDictionary&lt;TUser&gt;(document.ToDictionary());
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            var snapShot = await _usersClaims.WhereEqualTo(&quot;Type&quot;, claim.Type)
                .WhereEqualTo(&quot;Value&quot;, claim.Value)
                .GetSnapshotAsync(cancellationToken);
            var documents = snapShot.Documents;
            var list = new List&lt;TUser&gt;(documents.Count);
            foreach(var document in documents)
            {
                var user = await FindByIdAsync(document.GetValue&lt;string&gt;(&quot;UserId&quot;));
                if (user != null)
                {
                    list.Add(user);
                }
            }
            
            return list.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(string userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var snapShot = await _usersLogins.WhereEqualTo(&quot;UserId&quot;, userId)
                .WhereEqualTo(&quot;LoginProvider&quot;, loginProvider)
                .WhereEqualTo(&quot;ProviderKey&quot;, providerKey)
                .GetSnapshotAsync(cancellationToken);
            var document = snapShot.Documents.FirstOrDefault();
            if (document != null)
            {
                return Map.FromDictionary&lt;TUserLogin&gt;(document.ToDictionary());
            }
            return default(TUserLogin);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var snapShot = await _usersLogins.WhereEqualTo(&quot;LoginProvider&quot;, loginProvider)
                    .WhereEqualTo(&quot;ProviderKey&quot;, providerKey)
                    .GetSnapshotAsync(cancellationToken);
            var document = snapShot.Documents.FirstOrDefault();
            if (document != null)
            {
                return Map.FromDictionary&lt;TUserLogin&gt;(document.ToDictionary());
            }
            return default(TUserLogin);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var snapShot = await _usersTokens.WhereEqualTo(&quot;UserId&quot;, user.Id)
                .GetSnapshotAsync(cancellationToken);
            return snapShot.Documents
                .Select(d =&gt; Map.FromDictionary&lt;TUserToken&gt;(d.ToDictionary()))
                .ToList();
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            var snapShop = await _usersTokens.WhereEqualTo(&quot;UserId&quot;, user.Id)
                .GetSnapshotAsync(cancellationToken);
            foreach(var document in snapShop.Documents)
            {
                await _usersTokens.Document(document.Id).DeleteAsync(cancellationToken: cancellationToken);
            }

            foreach (var token in tokens)
            {
                var dictionary = Map.ToDictionary(token);
                dictionary[&quot;UserId&quot;] = user.Id;
                await _usersTokens.AddAsync(dictionary, cancellationToken);
            }
        }

        protected virtual Dictionary&lt;string, object&gt; ClaimsToDictionary(TUser user, Claim claim)
        {
            return new Dictionary&lt;string, object&gt;
                {
                    { &quot;UserId&quot;,  user.Id },
                    { &quot;Type&quot;, claim.Type },
                    { &quot;Value&quot;, claim.Value }
                };
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[23,89,23,108,0],[23,109,23,110,0],[23,111,23,112,0],[38,89,38,108,1],[38,109,38,110,1],[38,111,38,112,1],[83,13,83,14,1],[84,17,84,84,1],[85,17,85,46,1],[85,46,85,89,1],[85,89,85,105,1],[85,17,85,105,1],[86,13,86,14,1],[94,89,94,136,1],[95,9,95,10,1],[96,13,96,69,1],[97,13,97,52,1],[98,13,98,63,1],[99,13,99,63,1],[100,13,100,63,1],[101,9,101,10,1],[110,9,110,10,1],[111,13,111,62,1],[112,13,112,31,1],[113,13,113,30,1],[114,13,114,14,0],[115,17,115,63,0],[118,13,118,53,1],[119,13,119,118,1],[121,13,121,43,1],[122,9,122,10,1],[131,9,131,10,1],[132,13,132,62,1],[133,13,133,31,1],[134,13,134,30,1],[135,13,135,14,0],[136,17,136,63,0],[139,13,139,53,1],[140,13,141,16,1],[141,16,141,17,1],[141,17,142,20,1],[142,20,142,59,1],[142,59,143,20,1],[143,20,143,98,1],[143,98,144,20,1],[144,20,144,95,1],[144,95,145,20,1],[145,20,145,21,0],[145,21,146,24,1],[146,24,146,90,0],[146,90,148,20,1],[148,20,148,60,1],[148,60,149,20,1],[149,20,149,50,1],[149,50,150,16,1],[150,16,150,17,1],[150,17,150,57,1],[140,13,150,57,1],[151,9,151,10,1],[160,9,160,10,1],[161,13,161,62,1],[162,13,162,31,1],[163,13,163,30,1],[164,13,164,14,0],[165,17,165,63,0],[168,13,169,13,1],[169,13,169,14,1],[169,14,170,17,1],[170,17,170,56,1],[170,56,171,17,1],[171,17,171,95,1],[171,95,172,17,1],[172,17,172,92,1],[172,92,173,17,1],[173,17,173,18,0],[173,18,174,21,1],[174,21,174,87,0],[174,87,176,17,1],[176,17,176,45,1],[176,45,177,17,1],[177,17,177,47,1],[177,47,178,13,1],[178,13,178,14,1],[178,14,178,54,1],[168,13,178,54,1],[179,9,179,10,1],[190,9,190,10,1],[191,13,191,31,1],[192,13,192,51,1],[193,13,193,14,0],[194,17,194,65,0],[197,13,197,94,1],[198,13,198,34,1],[199,13,199,14,1],[200,17,200,75,1],[203,13,203,25,0],[204,9,204,10,1],[215,9,215,10,1],[216,13,216,31,1],[217,13,217,63,1],[218,13,218,14,0],[219,17,219,77,0],[222,13,223,54,1],[224,13,225,35,1],[226,13,226,34,1],[227,13,227,14,1],[228,17,228,75,1],[230,13,230,25,1],[231,9,231,10,1],[240,9,240,10,1],[241,13,241,31,1],[242,13,242,30,1],[243,13,243,14,0],[244,17,244,63,0],[247,13,248,54,1],[249,13,250,30,1],[250,30,250,96,1],[250,96,251,27,1],[249,13,251,27,1],[252,9,252,10,1],[262,9,262,10,1],[263,13,263,31,1],[264,13,264,30,1],[265,13,265,14,0],[266,17,266,63,0],[268,13,268,32,1],[269,13,269,14,0],[270,17,270,65,0],[273,13,273,20,1],[273,22,273,31,1],[273,32,273,34,1],[273,35,273,41,1],[274,13,274,14,1],[275,17,275,89,1],[276,17,276,76,1],[277,13,277,14,1],[278,9,278,10,1],[289,9,289,10,1],[290,13,290,31,1],[291,13,291,30,1],[292,13,292,14,0],[293,17,293,63,0],[295,13,295,31,1],[296,13,296,14,0],[297,17,297,64,0],[299,13,299,34,1],[300,13,300,14,0],[301,17,301,67,0],[304,13,305,13,1],[305,13,305,14,1],[305,14,306,17,1],[306,17,308,58,1],[308,58,309,17,1],[309,17,309,59,1],[309,59,310,17,1],[310,17,310,92,1],[310,92,311,13,1],[311,13,311,14,1],[311,14,311,54,1],[304,13,311,54,1],[312,9,312,10,1],[322,9,322,10,1],[323,13,323,31,1],[324,13,324,30,1],[325,13,325,14,0],[326,17,326,63,0],[328,13,328,32,1],[329,13,329,14,0],[330,17,330,65,0],[333,13,334,13,1],[334,13,334,14,1],[334,14,335,17,1],[335,17,335,24,1],[335,24,335,25,1],[335,25,335,34,1],[335,34,335,35,1],[335,35,335,37,1],[335,37,335,38,1],[335,38,335,44,1],[335,44,336,17,1],[336,17,336,18,1],[336,18,337,21,1],[337,21,339,62,1],[339,62,340,21,1],[340,21,340,63,1],[340,63,341,21,1],[341,21,341,60,1],[341,60,342,17,1],[342,17,342,18,1],[342,18,343,13,1],[343,13,343,14,1],[343,14,343,54,1],[333,13,343,54,1],[344,9,344,10,1],[355,9,355,10,1],[356,13,356,31,1],[357,13,357,30,1],[358,13,358,14,0],[359,17,359,63,0],[361,13,361,31,1],[362,13,362,14,0],[363,17,363,64,0],[366,13,372,15,1],[373,13,373,72,1],[373,73,373,74,1],[374,9,374,10,1],[386,9,386,10,1],[387,13,387,31,1],[388,13,388,30,1],[389,13,389,14,0],[390,17,390,63,0],[392,13,392,58,1],[393,13,393,14,0],[394,17,394,72,0],[396,13,396,56,1],[397,13,397,14,0],[398,17,398,70,0],[401,13,402,13,1],[402,13,402,14,1],[402,14,403,17,1],[403,17,406,58,1],[406,58,407,17,1],[407,17,407,59,1],[407,59,408,17,1],[408,17,408,56,1],[408,56,409,13,1],[409,13,409,14,1],[409,14,409,54,1],[401,13,409,54,1],[410,9,410,10,1],[421,9,421,10,1],[422,13,422,31,1],[423,13,423,30,1],[424,13,424,14,0],[425,17,425,63,0],[428,13,429,54,1],[430,13,430,48,1],[431,13,431,65,1],[432,13,432,20,1],[432,21,432,28,1],[432,29,432,31,1],[432,32,432,41,1],[433,13,433,14,1],[434,17,436,67,1],[437,13,437,14,1],[438,13,438,25,1],[439,9,439,10,1],[452,9,452,10,1],[453,13,453,31,1],[454,13,454,58,1],[455,13,455,14,0],[456,17,456,72,0],[458,13,458,56,1],[459,13,459,14,0],[460,17,460,70,0],[463,13,465,54,1],[466,13,466,64,1],[467,13,467,34,1],[468,13,468,14,1],[469,17,469,66,1],[470,17,470,71,1],[472,13,472,25,1],[473,9,473,10,1],[484,9,484,10,1],[485,13,485,31,1],[486,13,486,60,1],[487,13,487,14,0],[488,17,488,74,0],[490,13,491,54,1],[492,13,492,64,1],[493,13,493,34,1],[494,13,494,14,1],[495,17,495,75,1],[497,13,497,25,1],[498,9,498,10,1],[509,9,509,10,1],[510,13,510,31,1],[511,13,511,31,1],[512,13,512,14,0],[513,17,513,64,0],[516,13,518,54,1],[519,13,519,48,1],[520,13,520,57,1],[521,13,521,20,1],[521,21,521,33,1],[521,34,521,36,1],[521,37,521,46,1],[522,13,522,14,1],[523,17,523,85,1],[524,17,524,34,1],[525,17,525,18,1],[526,21,526,36,1],[527,17,527,18,1],[528,13,528,14,1],[530,13,530,34,1],[531,9,531,10,1],[542,9,542,10,0],[543,13,543,94,0],[544,9,544,10,0],[554,9,554,10,0],[555,13,555,86,0],[556,9,556,10,0],[565,9,565,10,1],[566,13,566,64,1],[567,9,567,10,1],[577,9,577,10,1],[578,13,578,73,1],[579,9,579,10,1],[588,9,588,10,0],[589,13,589,72,0],[590,9,590,10,0],[601,9,601,10,0],[602,13,605,54,0],[606,13,606,64,0],[607,13,607,34,0],[608,13,608,14,0],[609,17,609,80,0],[611,13,611,40,0],[612,9,612,10,0],[622,9,622,10,0],[623,13,625,58,0],[626,13,626,64,0],[627,13,627,34,0],[628,13,628,14,0],[629,17,629,80,0],[631,13,631,40,0],[632,9,632,10,0],[641,9,641,10,1],[642,13,643,54,1],[644,13,645,30,1],[645,30,645,78,1],[645,78,646,27,1],[644,13,646,27,1],[647,9,647,10,1],[657,9,657,10,1],[658,13,659,54,1],[660,13,660,20,1],[660,21,660,33,1],[660,34,660,36,1],[660,37,660,55,1],[661,13,661,14,1],[662,17,662,108,1],[663,13,663,14,1],[665,13,665,20,1],[665,22,665,31,1],[665,32,665,34,1],[665,35,665,41,1],[666,13,666,14,1],[667,17,667,58,1],[668,17,668,48,1],[669,17,669,76,1],[670,13,670,14,1],[671,9,671,10,1],[674,9,674,10,1],[675,13,680,19,1],[681,9,681,10,1]]);
    </script>
  </body>
</html>