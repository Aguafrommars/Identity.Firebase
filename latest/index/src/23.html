<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Aguacongas.Firebase;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore: UserOnlyStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, IdentityUserClaim&lt;string&gt;, IdentityUserLogin&lt;string&gt;, IdentityUserToken&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt; :
        FirebaseUserStoreBase&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;string&gt;
        where TUserClaim : IdentityUserClaim&lt;string&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;string&gt;, new()
        where TUserToken : IdentityUserToken&lt;string&gt;, new()
    {
        private const string UsersTableName = &quot;users&quot;;
        private const string UserLoginsTableName = &quot;user-logins&quot;;
        private const string UserClaimsTableName = &quot;user-claims&quot;;
        private const string UserTokensTableName = &quot;user-tokens&quot;;

        private readonly IFirebaseClient _client;

        /// &lt;summary&gt;
        /// A navigation property for the users the store contains.
        /// &lt;/summary&gt;
        public override IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var response = _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName)).GetAwaiter().GetResult();
                var userDictionary = response.Data;
                if (userDictionary == null)
                {
                    return new List&lt;TUser&gt;().AsQueryable();
                }

                return userDictionary.Select(kv =&gt;
                {
                    var user = kv.Value;
                    user.Id = kv.Key;
                    return user;
                }).AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.PostAsync(GetFirebasePath(UsersTableName), user, cancellationToken);
            user.Id = response.Data;
            user.ConcurrencyStamp = response.Etag;
            
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync(GetFirebasePath(UsersTableName, user.Id), user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync(GetFirebasePath(UsersTableName, user.Id), cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;(GetFirebasePath(UsersTableName, userId), cancellationToken, true);
            var user = response.Data;
            if (user != null)
            {
                user.Id = userId;
                user.ConcurrencyStamp = response.Etag;
            }
            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach(var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
                
            }
            catch(FirebaseException e)
               when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
            }
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            
            if (data != null)
            {
                return data.Select(c =&gt; c.Value.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var taskList = new List&lt;Task&gt;(userClaims.Count);
            foreach(var userClaim in userClaims)
            {
                taskList.Add(_client.PostAsync(GetFirebasePath(UserClaimsTableName), userClaim, cancellationToken));
            }

            await Task.WhenAll(taskList.ToArray());
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            data = data ?? new Dictionary&lt;string, TUserClaim&gt;();
            foreach(var kv in data)
            {
                var uc = kv.Value;
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;

                    await _client.PutAsync(GetFirebasePath(UserClaimsTableName, kv.Key), uc, cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                var taskList = new List&lt;Task&gt;(claims.Count());
                foreach (var claim in claims)
                {
                    var match = data.SingleOrDefault(kv =&gt; kv.Value.ClaimType == claim.Type &amp;&amp; kv.Value.ClaimValue == claim.Value);
                    if (match.Key != null)
                    {
                        taskList.Add(_client.DeleteAsync(GetFirebasePath(UserClaimsTableName, match.Key), cancellationToken));
                    }
                }

                Task.WaitAll(taskList.ToArray());
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            await _client.PostAsync(GetFirebasePath(UserLoginsTableName), CreateUserLogin(user, login), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = await GetUserLoginsAsync(user.Id, cancellationToken);

            foreach (var kv in data)
            {
                var login = kv.Value;
                if (login.LoginProvider == loginProvider &amp;&amp; login.ProviderKey == providerKey)
                {
                    await _client.DeleteAsync(GetFirebasePath(UserLoginsTableName, kv.Key), cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values
                    .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                    .ToList();
            }
            return new List&lt;UserLoginInfo&gt;(0);
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }

            if (data == null)
            {
                return new List&lt;TUser&gt;(0);
            }

            var userIds = data.Values.Where(c =&gt; c.ClaimValue == claim.Value).Select(c =&gt; c.UserId);
            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(userIds.Count());
            foreach (var userId in userIds)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(string userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId, cancellationToken);
            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;List&lt;TUserToken&gt;&gt;(GetFirebasePath(UserTokensTableName, user.Id), cancellationToken);
            return response.Data ?? new List&lt;TUserToken&gt;();
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            await _client.PutAsync(GetFirebasePath(UserTokensTableName, user.Id), tokens, cancellationToken);
        }

        protected virtual async Task&lt;Dictionary&lt;string, TUserLogin&gt;&gt; GetUserLoginsAsync(string userId, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }

            return data;
        }


        protected virtual void SetIndex(Dictionary&lt;string, object&gt; rules, string key, object index)
        {
            rules[key] = index;
        }

        internal async Task SetIndex(string onTable, object index, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;FirebaseRules&gt;(RulePath, cancellationToken);
            var rules = response.Data ?? new FirebaseRules();
            SetIndex(rules.Rules, onTable, index);
            await _client.PutAsync(RulePath, rules, cancellationToken);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,97,24,120,1],[24,121,24,122,1],[24,123,24,124,1],[39,97,39,120,1],[39,121,39,122,1],[39,123,39,124,1],[80,13,80,14,1],[81,17,81,134,1],[82,17,82,52,1],[83,17,83,44,1],[84,17,84,18,0],[85,21,85,60,0],[88,17,89,17,1],[89,17,89,18,1],[89,18,90,21,1],[90,21,90,41,1],[90,41,91,21,1],[91,21,91,38,1],[91,38,92,21,1],[92,21,92,33,1],[92,33,93,17,1],[93,17,93,18,1],[93,18,93,34,1],[88,17,93,34,1],[94,13,94,14,1],[102,97,102,144,1],[103,9,103,10,1],[104,13,104,81,1],[105,9,105,10,1],[114,9,114,10,1],[115,13,115,62,1],[116,13,116,31,1],[117,13,117,30,1],[118,13,118,14,1],[119,17,119,63,1],[121,13,121,110,1],[122,13,122,37,1],[123,13,123,51,1],[125,13,125,43,1],[126,9,126,10,1],[135,9,135,10,1],[136,13,136,62,1],[137,13,137,31,1],[138,13,138,30,1],[139,13,139,14,1],[140,17,140,63,1],[144,13,144,14,1],[145,17,145,151,1],[146,17,146,55,1],[147,13,147,14,1],[149,17,149,73,0],[150,13,150,14,0],[151,17,151,83,0],[154,13,154,43,1],[155,9,155,10,1],[164,9,164,10,1],[165,13,165,62,1],[166,13,166,31,1],[167,13,167,30,1],[168,13,168,14,1],[169,17,169,63,1],[173,13,173,14,1],[174,17,174,133,1],[175,13,175,14,1],[177,17,177,73,0],[178,13,178,14,0],[179,17,179,83,0],[181,13,181,43,1],[182,9,182,10,1],[193,9,193,10,1],[194,13,194,62,1],[195,13,195,31,1],[196,13,196,124,1],[197,13,197,38,1],[198,13,198,30,1],[199,13,199,14,1],[200,17,200,34,1],[201,17,201,55,1],[202,13,202,14,1],[203,13,203,25,1],[204,9,204,10,1],[215,9,215,10,1],[216,13,216,62,1],[217,13,217,31,1],[219,13,219,14,1],[220,17,220,209,1],[221,17,221,24,1],[221,25,221,31,1],[221,32,221,34,1],[221,35,221,48,1],[222,17,222,18,1],[223,21,223,75,1],[225,17,225,29,1],[229,16,229,91,1],[230,13,230,14,1],[231,17,231,84,1],[233,17,233,209,1],[234,17,234,24,1],[234,26,234,32,0],[234,33,234,35,1],[234,36,234,49,1],[235,17,235,18,0],[236,21,236,75,0],[238,17,238,29,1],[240,9,240,10,1],[249,9,249,10,1],[250,13,250,62,1],[251,13,251,31,1],[252,13,252,30,1],[253,13,253,14,1],[254,17,254,63,1],[259,13,259,14,1],[260,17,260,196,1],[261,17,261,38,1],[262,13,262,14,1],[264,17,264,92,1],[265,13,265,14,1],[266,17,266,94,1],[268,17,268,202,1],[269,17,269,38,1],[270,13,270,14,1],[272,13,272,30,1],[273,13,273,14,1],[274,17,274,41,1],[274,41,274,58,1],[274,58,274,69,1],[274,17,274,69,1],[276,13,276,39,0],[277,9,277,10,1],[287,9,287,10,1],[288,13,288,62,1],[289,13,289,31,1],[290,13,290,30,1],[291,13,291,14,1],[292,17,292,63,1],[294,13,294,32,1],[295,13,295,14,1],[296,17,296,65,1],[299,13,299,62,1],[299,62,299,86,1],[299,86,299,97,1],[299,13,299,97,1],[300,13,300,61,1],[301,13,301,20,1],[301,21,301,34,1],[301,35,301,37,1],[301,38,301,48,1],[302,13,302,14,1],[303,17,303,117,1],[304,13,304,14,1],[306,13,306,52,1],[307,9,307,10,1],[318,9,318,10,1],[319,13,319,62,1],[320,13,320,31,1],[321,13,321,30,1],[322,13,322,14,1],[323,17,323,63,1],[325,13,325,31,1],[326,13,326,14,0],[327,17,327,64,0],[329,13,329,34,1],[330,13,330,14,0],[331,17,331,67,0],[336,13,336,14,1],[337,17,337,196,1],[338,17,338,38,1],[339,13,339,14,1],[341,17,341,92,0],[342,13,342,14,0],[343,17,343,94,0],[345,17,345,202,0],[346,17,346,38,0],[347,13,347,14,0],[349,13,349,65,1],[350,13,350,20,1],[350,21,350,27,1],[350,28,350,30,1],[350,31,350,35,1],[351,13,351,14,1],[352,17,352,35,1],[353,17,353,80,1],[354,17,354,18,1],[355,21,355,50,1],[356,21,356,52,1],[358,21,358,113,1],[359,17,359,18,1],[360,13,360,14,1],[361,9,361,10,1],[371,9,371,10,1],[372,13,372,31,1],[373,13,373,30,1],[374,13,374,14,1],[375,17,375,63,1],[377,13,377,32,1],[378,13,378,14,1],[379,17,379,65,1],[384,13,384,14,1],[385,17,385,196,1],[386,17,386,38,1],[387,13,387,14,1],[389,17,389,92,0],[390,13,390,14,0],[391,17,391,94,0],[393,17,393,202,0],[394,17,394,38,0],[395,13,395,14,0],[397,13,397,30,1],[398,13,398,14,1],[399,17,399,63,1],[400,17,400,24,1],[400,26,400,35,1],[400,36,400,38,1],[400,39,400,45,1],[401,17,401,18,1],[402,21,402,60,1],[402,60,402,130,1],[402,130,402,132,1],[402,21,402,132,1],[403,21,403,43,1],[404,21,404,22,1],[405,25,405,127,1],[406,21,406,22,1],[407,17,407,18,1],[409,17,409,50,1],[410,13,410,14,1],[411,9,411,10,1],[422,9,422,10,1],[423,13,423,62,1],[424,13,424,31,1],[425,13,425,30,1],[426,13,426,14,1],[427,17,427,63,1],[429,13,429,31,1],[430,13,430,14,1],[431,17,431,64,1],[434,13,434,124,1],[435,9,435,10,1],[447,9,447,10,1],[448,13,448,62,1],[449,13,449,31,1],[450,13,450,30,1],[451,13,451,14,1],[452,17,452,63,1],[455,13,455,77,1],[457,13,457,20,1],[457,22,457,28,1],[457,29,457,31,1],[457,32,457,36,1],[458,13,458,14,1],[459,17,459,38,1],[460,17,460,94,1],[461,17,461,18,1],[462,21,462,112,1],[463,17,463,18,1],[464,13,464,14,1],[465,9,465,10,1],[476,9,476,10,1],[477,13,477,62,1],[478,13,478,31,1],[479,13,479,30,1],[480,13,480,14,1],[481,17,481,63,1],[486,13,486,14,1],[487,17,487,196,1],[488,17,488,38,1],[489,13,489,14,1],[491,17,491,92,1],[492,13,492,14,1],[493,17,493,90,1],[495,17,495,202,1],[496,17,496,38,1],[497,13,497,14,1],[499,13,499,30,1],[500,13,500,14,1],[501,17,502,34,1],[502,34,502,106,1],[502,106,503,31,1],[501,17,503,31,1],[505,13,505,47,0],[506,9,506,10,1],[519,9,519,10,1],[520,13,520,62,1],[521,13,521,31,1],[522,13,522,101,1],[523,13,523,35,1],[524,13,524,14,1],[525,17,525,81,1],[527,13,527,25,1],[528,9,528,10,1],[539,9,539,10,1],[540,13,540,62,1],[541,13,541,31,1],[544,13,544,14,1],[545,17,545,203,1],[546,17,546,24,1],[546,26,546,32,1],[546,33,546,35,1],[546,36,546,49,1],[547,17,547,18,1],[548,21,548,75,1],[550,17,550,29,1],[554,17,554,92,0],[555,13,555,14,0],[556,17,556,84,0],[558,17,558,203,0],[559,17,559,24,0],[559,26,559,32,0],[559,33,559,35,0],[559,36,559,49,0],[560,17,560,18,0],[561,21,561,75,0],[563,17,563,29,0],[566,9,566,10,1],[577,9,577,10,1],[578,13,578,62,1],[579,13,579,31,1],[580,13,580,31,1],[581,13,581,14,0],[582,17,582,64,0],[587,13,587,14,1],[588,17,588,202,1],[589,17,589,38,1],[590,13,590,14,1],[592,17,592,92,0],[593,13,593,14,0],[594,17,594,94,0],[596,17,596,208,0],[597,17,597,38,0],[598,13,598,14,0],[600,13,600,30,1],[601,13,601,14,0],[602,17,602,43,0],[605,13,605,50,1],[605,50,605,77,1],[605,77,605,91,1],[605,91,605,99,1],[605,99,605,101,1],[605,13,605,101,1],[606,13,606,52,1],[607,13,607,60,1],[608,13,608,20,1],[608,22,608,32,1],[608,33,608,35,1],[608,36,608,43,1],[609,13,609,14,1],[610,17,610,51,1],[610,51,610,52,1],[610,52,611,21,1],[611,21,611,79,1],[611,79,612,21,1],[612,21,612,38,1],[612,38,613,21,1],[613,21,613,22,1],[613,22,614,25,1],[614,25,614,41,1],[614,41,615,21,1],[615,21,615,22,1],[615,22,616,17,1],[616,17,616,18,1],[616,18,616,21,1],[610,17,616,21,1],[617,13,617,14,1],[619,13,619,46,1],[621,13,621,35,1],[622,9,622,10,1],[633,9,633,10,0],[634,13,634,94,0],[635,9,635,10,0],[645,9,645,10,0],[646,13,646,86,0],[647,9,647,10,0],[656,9,656,10,1],[657,13,657,64,1],[658,9,658,10,1],[668,9,668,10,1],[669,13,669,73,1],[670,9,670,10,1],[679,9,679,10,1],[680,13,680,72,1],[681,9,681,10,1],[692,9,692,10,0],[693,13,693,76,0],[694,13,694,30,0],[695,13,695,14,0],[696,17,696,56,0],[696,56,696,120,0],[696,120,696,122,0],[696,17,696,122,0],[698,13,698,25,0],[699,9,699,10,0],[709,9,709,10,1],[712,13,712,14,1],[713,17,713,205,1],[714,17,714,38,1],[715,13,715,14,1],[717,17,717,92,1],[718,13,718,14,1],[719,17,719,90,1],[721,17,721,211,1],[722,17,722,38,1],[723,13,723,14,1],[725,13,725,30,1],[726,13,726,14,1],[727,17,727,56,1],[727,56,727,120,1],[727,120,727,122,1],[727,17,727,122,1],[729,13,729,25,0],[730,9,730,10,1],[739,9,739,10,1],[740,13,740,135,1],[741,13,741,60,1],[742,9,742,10,1],[752,9,752,10,1],[753,13,753,110,1],[754,9,754,10,1],[757,9,757,10,1],[760,13,760,14,1],[761,17,761,195,1],[762,17,762,38,1],[763,13,763,14,1],[765,17,765,92,0],[766,13,766,14,0],[767,17,767,90,0],[769,17,769,201,0],[770,17,770,38,0],[771,13,771,14,0],[773,13,773,25,1],[774,9,774,10,1],[778,9,778,10,1],[779,13,779,32,1],[780,9,780,10,1],[783,9,783,10,1],[784,13,784,95,1],[785,13,785,62,1],[786,13,786,51,1],[787,13,787,72,1],[788,9,788,10,1]]);
    </script>
  </body>
</html>