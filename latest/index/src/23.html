<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>C:\projects\identity-firebase\src\Aguacongas.Identity.Firebase\UserOnlyStore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using Aguacongas.Firebase;
using Microsoft.AspNetCore.Identity;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Threading;
using System.Threading.Tasks;

namespace Aguacongas.Identity.Firebase
{
    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for &lt;see cref=&quot;IdentityUser&quot;/&gt;.
    /// &lt;/summary&gt;
    public class UserOnlyStore: UserOnlyStore&lt;IdentityUser&lt;string&gt;&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser&gt; : UserOnlyStore&lt;TUser, IdentityUserClaim&lt;string&gt;, IdentityUserLogin&lt;string&gt;, IdentityUserToken&lt;string&gt;&gt;
        where TUser : IdentityUser&lt;string&gt;
    {
        /// &lt;summary&gt;
        /// Constructs a new instance of &lt;see cref=&quot;UserStore{TUser, TRole, TKey}&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt;.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(client, describer) { }
    }

    /// &lt;summary&gt;
    /// Represents a new instance of a persistence store for the specified user and role types.
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;TUser&quot;&gt;The type representing a user.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserClaim&quot;&gt;The type representing a claim.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserLogin&quot;&gt;The type representing a user external login.&lt;/typeparam&gt;
    /// &lt;typeparam name=&quot;TUserToken&quot;&gt;The type representing a user token.&lt;/typeparam&gt;
    public class UserOnlyStore&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt; :
        FirebaseUserStoreBase&lt;TUser, TUserClaim, TUserLogin, TUserToken&gt;,
        IQueryableUserStore&lt;TUser&gt;,
        IUserLoginStore&lt;TUser&gt;,
        IUserClaimStore&lt;TUser&gt;,
        IUserPasswordStore&lt;TUser&gt;,
        IUserSecurityStampStore&lt;TUser&gt;,
        IUserEmailStore&lt;TUser&gt;,
        IUserLockoutStore&lt;TUser&gt;,
        IUserPhoneNumberStore&lt;TUser&gt;,
        IUserTwoFactorStore&lt;TUser&gt;,
        IUserAuthenticationTokenStore&lt;TUser&gt;,
        IUserAuthenticatorKeyStore&lt;TUser&gt;,
        IUserTwoFactorRecoveryCodeStore&lt;TUser&gt;
        where TUser : IdentityUser&lt;string&gt;
        where TUserClaim : IdentityUserClaim&lt;string&gt;, new()
        where TUserLogin : IdentityUserLogin&lt;string&gt;, new()
        where TUserToken : IdentityUserToken&lt;string&gt;, new()
    {
        private const string UsersTableName = &quot;users&quot;;
        private const string UserLoginsTableName = &quot;user-logins&quot;;
        private const string UserClaimsTableName = &quot;user-claims&quot;;
        private const string UserTokensTableName = &quot;user-tokens&quot;;

        private readonly IFirebaseClient _client;

        public IQueryable&lt;TUser&gt; Users
        {
            get
            {
                var response = _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName)).GetAwaiter().GetResult();
                var userDictionary = response.Data;
                if (userDictionary == null)
                {
                    return new List&lt;TUser&gt;().AsQueryable();
                }

                return userDictionary.Select(kv =&gt;
                {
                    var user = kv.Value;
                    user.Id = kv.Key;
                    return user;
                }).AsQueryable();
            }
        }

        /// &lt;summary&gt;
        /// Creates a new instance of the store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The &lt;see cref=&quot;IFirebaseClient&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;describer&quot;&gt;The &lt;see cref=&quot;IdentityErrorDescriber&quot;/&gt; used to describe store errors.&lt;/param&gt;
        public UserOnlyStore(IFirebaseClient client, IdentityErrorDescriber describer = null) : base(describer ?? new IdentityErrorDescriber())
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
        }

        /// &lt;summary&gt;
        /// Creates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to create.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the creation operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; CreateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            var response = await _client.PostAsync(GetFirebasePath(UsersTableName), user, cancellationToken);
            user.Id = response.Data;
            user.ConcurrencyStamp = response.Etag;
            
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Updates the specified &lt;paramref name=&quot;user&quot;/&gt; in the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to update.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; UpdateAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                var response = await _client.PutAsync(GetFirebasePath(UsersTableName, user.Id), user, cancellationToken, true, user.ConcurrencyStamp);
                user.ConcurrencyStamp = response.Etag;
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }

            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Deletes the specified &lt;paramref name=&quot;user&quot;/&gt; from the user store.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to delete.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the &lt;see cref=&quot;IdentityResult&quot;/&gt; of the update operation.&lt;/returns&gt;
        public async override Task&lt;IdentityResult&gt; DeleteAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            try
            {
                await _client.DeleteAsync(GetFirebasePath(UsersTableName, user.Id), cancellationToken, true, user.ConcurrencyStamp);
            }
            catch (FirebaseException e)
                when (e.StatusCode == HttpStatusCode.PreconditionFailed)
            {
                return IdentityResult.Failed(ErrorDescriber.ConcurrencyFailure());
            }
            return IdentityResult.Success;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified &lt;paramref name=&quot;userId&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user ID to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;userId&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var response = await _client.GetAsync&lt;TUser&gt;(GetFirebasePath(UsersTableName, userId), cancellationToken, true);
            var user = response.Data;
            if (user != null)
            {
                user.Id = userId;
                user.ConcurrencyStamp = response.Etag;
            }
            return user;
        }

        /// &lt;summary&gt;
        /// Finds and returns a user, if any, who has the specified normalized user name.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedUserName&quot;&gt;The normalized user name to search for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation, containing the user matching the specified &lt;paramref name=&quot;normalizedUserName&quot;/&gt; if it exists.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach(var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
                
            }
            catch(FirebaseException e)
               when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedUserName\&quot;&amp;equalTo=\&quot;{normalizedUserName}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;
            }
        }

        /// &lt;summary&gt;
        /// Get the claims associated with the specified &lt;paramref name=&quot;user&quot;/&gt; as an asynchronous operation.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose claims should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;A &lt;see cref=&quot;Task{TResult}&quot;/&gt; that contains the claims granted to a user.&lt;/returns&gt;
        public async override Task&lt;IList&lt;Claim&gt;&gt; GetClaimsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            
            if (data != null)
            {
                return data.Select(c =&gt; c.Value.ToClaim()).ToList();
            }
            return new List&lt;Claim&gt;(0);
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;claims&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the claim to.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            List&lt;TUserClaim&gt; userClaims = claims.Select(c =&gt; CreateUserClaim(user, c)).ToList();
            var taskList = new List&lt;Task&gt;(userClaims.Count);
            foreach(var userClaim in userClaims)
            {
                taskList.Add(_client.PostAsync(GetFirebasePath(UserClaimsTableName), userClaim, cancellationToken));
            }

            Task.WaitAll(taskList.ToArray());
        }

        /// &lt;summary&gt;
        /// Replaces the &lt;paramref name=&quot;claim&quot;/&gt; on the specified &lt;paramref name=&quot;user&quot;/&gt;, with the &lt;paramref name=&quot;newClaim&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to replace the claim on.&lt;/param&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim replace.&lt;/param&gt;
        /// &lt;param name=&quot;newClaim&quot;&gt;The new claim replacing the &lt;paramref name=&quot;claim&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task ReplaceClaimAsync(TUser user, Claim claim, Claim newClaim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }
            if (newClaim == null)
            {
                throw new ArgumentNullException(nameof(newClaim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            data = data ?? new Dictionary&lt;string, TUserClaim&gt;();
            foreach(var kv in data)
            {
                var uc = kv.Value;
                if (uc.ClaimType == claim.Type &amp;&amp; uc.ClaimValue == claim.Value)
                {
                    uc.ClaimType = newClaim.Type;
                    uc.ClaimValue = newClaim.Value;

                    await _client.PutAsync(GetFirebasePath(UserClaimsTableName, kv.Key), uc, cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;claims&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the claims from.&lt;/param&gt;
        /// &lt;param name=&quot;claims&quot;&gt;The claim to remove.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public async override Task RemoveClaimsAsync(TUser user, IEnumerable&lt;Claim&gt; claims, CancellationToken cancellationToken = default(CancellationToken))
        {
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (claims == null)
            {
                throw new ArgumentNullException(nameof(claims));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                var taskList = new List&lt;Task&gt;(claims.Count());
                foreach (var claim in claims)
                {
                    var match = data.SingleOrDefault(kv =&gt; kv.Value.ClaimType == claim.Type &amp;&amp; kv.Value.ClaimValue == claim.Value);
                    if (match.Key != null)
                    {
                        taskList.Add(_client.DeleteAsync(GetFirebasePath(UserClaimsTableName, match.Key), cancellationToken));
                    }
                }

                Task.WaitAll(taskList.ToArray());
            }
        }

        /// &lt;summary&gt;
        /// Adds the &lt;paramref name=&quot;login&quot;/&gt; given to the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to add the login to.&lt;/param&gt;
        /// &lt;param name=&quot;login&quot;&gt;The login to add to the user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task AddLoginAsync(TUser user, UserLoginInfo login,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }
            if (login == null)
            {
                throw new ArgumentNullException(nameof(login));
            }

            await _client.PostAsync(GetFirebasePath(UserLoginsTableName), CreateUserLogin(user, login), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Removes the &lt;paramref name=&quot;loginProvider&quot;/&gt; given from the specified &lt;paramref name=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user to remove the login from.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login to remove from the user.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The &lt;see cref=&quot;Task&quot;/&gt; that represents the asynchronous operation.&lt;/returns&gt;
        public override async Task RemoveLoginAsync(TUser user, string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = await GetUserLoginsAsync(user.Id, cancellationToken);

            foreach (var kv in data)
            {
                var login = kv.Value;
                if (login.LoginProvider == loginProvider &amp;&amp; login.ProviderKey == providerKey)
                {
                    await _client.DeleteAsync(GetFirebasePath(UserLoginsTableName, kv.Key), cancellationToken);
                }
            }
        }

        /// &lt;summary&gt;
        /// Retrieves the associated logins for the specified &lt;param ref=&quot;user&quot;/&gt;.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The user whose associated logins to retrieve.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing a list of &lt;see cref=&quot;UserLoginInfo&quot;/&gt; for the specified &lt;paramref name=&quot;user&quot;/&gt;, if any.
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;UserLoginInfo&gt;&gt; GetLoginsAsync(TUser user, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{user.Id}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values
                    .Select(l =&gt; new UserLoginInfo(l.LoginProvider, l.ProviderKey, l.ProviderDisplayName))
                    .ToList();
            }
            return new List&lt;UserLoginInfo&gt;(0);
        }

        /// &lt;summary&gt;
        /// Retrieves the user associated with the specified login provider and login provider key.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider who provided the &lt;paramref name=&quot;providerKey&quot;/&gt;.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; for the asynchronous operation, containing the user, if any which matched the specified login provider and key.
        /// &lt;/returns&gt;
        public async override Task&lt;TUser&gt; FindByLoginAsync(string loginProvider, string providerKey,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            var userLogin = await FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
            if (userLogin != null)
            {
                return await FindUserAsync(userLogin.UserId, cancellationToken);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Gets the user, if any, associated with the specified, normalized email address.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;normalizedEmail&quot;&gt;The normalized email address to return the user for.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The task object containing the results of the asynchronous lookup operation, the user if any associated with the specified normalized email address.
        /// &lt;/returns&gt;
        public override async Task&lt;TUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();

            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UsersTableName, new UserIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUser&gt;&gt;(GetFirebasePath(UsersTableName), cancellationToken, false, $&quot;orderBy=\&quot;NormalizedEmail\&quot;&amp;equalTo=\&quot;{normalizedEmail}\&quot;&quot;);
                foreach (var kv in response.Data)
                {
                    return await FindByIdAsync(kv.Key, cancellationToken);
                }
                return null;

            }
        }

        /// &lt;summary&gt;
        /// Retrieves all users with the specified claim.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;claim&quot;&gt;The claim whose users should be retrieved.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;
        /// The &lt;see cref=&quot;Task&quot;/&gt; contains a list of users, if any, that contain the specified claim. 
        /// &lt;/returns&gt;
        public async override Task&lt;IList&lt;TUser&gt;&gt; GetUsersForClaimAsync(Claim claim, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            ThrowIfDisposed();
            if (claim == null)
            {
                throw new ArgumentNullException(nameof(claim));
            }

            Dictionary&lt;string, TUserClaim&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserClaimsTableName, new UserClaimIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserClaim&gt;&gt;(GetFirebasePath(UserClaimsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ClaimType\&quot;&amp;equalTo=\&quot;{claim.Type}\&quot;&quot;);
                data = response.Data;
            }

            if (data == null)
            {
                return new List&lt;TUser&gt;(0);
            }

            var userIds = data.Values.Where(c =&gt; c.ClaimValue == claim.Value).Select(c =&gt; c.UserId);
            var users = new ConcurrentBag&lt;TUser&gt;();
            var taskList = new List&lt;Task&gt;(userIds.Count());
            foreach (var userId in userIds)
            {
                taskList.Add(Task.Run(async () =&gt; {
                    var user = await FindByIdAsync(userId, cancellationToken);
                    if (user != null)
                    {
                        users.Add(user);
                    }
                }));
            }

            Task.WaitAll(taskList.ToArray());

            return users.ToList();
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(userId, loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        internal Task&lt;TUserLogin&gt; FindUserLoginInternalAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            return FindUserLoginAsync(loginProvider, providerKey, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        internal Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensInternalAsync(TUser user, CancellationToken cancellationToken)
        {
            return GetUserTokensAsync(user, cancellationToken);
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        internal Task SaveUserTokensInternalAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            return SaveUserTokensAsync(user, tokens, cancellationToken);
        }
        
        /// &lt;summary&gt;
        /// Return a user with the matching userId if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user if it exists.&lt;/returns&gt;
        protected override Task&lt;TUser&gt; FindUserAsync(string userId, CancellationToken cancellationToken)
        {
            return FindByIdAsync(userId.ToString(), cancellationToken);
        }

        /// &lt;summary&gt;
        /// Return a user login with the matching userId, provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;userId&quot;&gt;The user&#39;s id.&lt;/param&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string userId, string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            var data = await GetUserLoginsAsync(userId, cancellationToken);
            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Return a user login with  provider, providerKey if it exists.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;loginProvider&quot;&gt;The login provider name.&lt;/param&gt;
        /// &lt;param name=&quot;providerKey&quot;&gt;The key provided by the &lt;paramref name=&quot;loginProvider&quot;/&gt; to identify a user.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;The user login if it exists.&lt;/returns&gt;
        protected override async Task&lt;TUserLogin&gt; FindUserLoginAsync(string loginProvider, string providerKey, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;ProviderKey\&quot;&amp;equalTo=\&quot;{providerKey}\&quot;&quot;);
                data = response.Data;
            }

            if (data != null)
            {
                return data.Values.FirstOrDefault(l =&gt; l.LoginProvider == loginProvider &amp;&amp; l.ProviderKey == providerKey);
            }
            return null;
        }

        /// &lt;summary&gt;
        /// Get user tokens
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The token owner.&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;User tokens.&lt;/returns&gt;
        protected override async Task&lt;List&lt;TUserToken&gt;&gt; GetUserTokensAsync(TUser user, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;List&lt;TUserToken&gt;&gt;(GetFirebasePath(UserTokensTableName, user.Id), cancellationToken);
            return response.Data ?? new List&lt;TUserToken&gt;();
        }

        /// &lt;summary&gt;
        /// Save user tokens.
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;user&quot;&gt;The tokens owner.&lt;/param&gt;
        /// &lt;param name=&quot;tokens&quot;&gt;Tokens to save&lt;/param&gt;
        /// &lt;param name=&quot;cancellationToken&quot;&gt;The &lt;see cref=&quot;CancellationToken&quot;/&gt; used to propagate notifications that the operation should be canceled.&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        protected override async Task SaveUserTokensAsync(TUser user, IEnumerable&lt;TUserToken&gt; tokens, CancellationToken cancellationToken)
        {
            await _client.PutAsync(GetFirebasePath(UserTokensTableName, user.Id), tokens, cancellationToken);
        }

        protected virtual async Task&lt;Dictionary&lt;string, TUserLogin&gt;&gt; GetUserLoginsAsync(string userId, CancellationToken cancellationToken)
        {
            Dictionary&lt;string, TUserLogin&gt; data;
            try
            {
                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, false, $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }
            catch (FirebaseException e)
                when (e.FirebaseError != null &amp;&amp; e.FirebaseError.Error.StartsWith(&quot;Index&quot;))
            {
                await SetIndex(UserLoginsTableName, new LoginIndex(), cancellationToken);

                var response = await _client.GetAsync&lt;Dictionary&lt;string, TUserLogin&gt;&gt;(GetFirebasePath(UserLoginsTableName), cancellationToken, queryString: $&quot;orderBy=\&quot;UserId\&quot;&amp;equalTo=\&quot;{userId}\&quot;&quot;);
                data = response.Data;
            }

            return data;
        }


        protected virtual void SetIndex(Dictionary&lt;string, object&gt; rules, string key, object index)
        {
            rules[key] = index;
        }

        internal async Task SetIndex(string onTable, object index, CancellationToken cancellationToken)
        {
            var response = await _client.GetAsync&lt;FirebaseRules&gt;(RulePath, cancellationToken);
            var rules = response.Data ?? new FirebaseRules();
            SetIndex(rules.Rules, onTable, index);
            await _client.PutAsync(RulePath, rules, cancellationToken);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,97,24,120,1],[24,121,24,122,1],[24,123,24,124,1],[39,97,39,120,1],[39,121,39,122,1],[39,123,39,124,1],[78,13,78,14,0],[79,17,79,134,0],[80,17,80,52,0],[81,17,81,44,0],[82,17,82,18,0],[83,21,83,60,0],[86,17,87,17,0],[87,17,87,18,0],[87,18,88,21,0],[88,21,88,41,0],[88,41,89,21,0],[89,21,89,38,0],[89,38,90,21,0],[90,21,90,33,0],[90,33,91,17,0],[91,17,91,18,0],[91,18,91,34,0],[86,17,91,34,0],[92,13,92,14,0],[100,97,100,144,1],[101,9,101,10,1],[102,13,102,81,1],[103,9,103,10,1],[112,9,112,10,1],[113,13,113,62,1],[114,13,114,31,1],[115,13,115,30,1],[116,13,116,14,1],[117,17,117,63,1],[119,13,119,110,1],[120,13,120,37,1],[121,13,121,51,1],[123,13,123,43,1],[124,9,124,10,1],[133,9,133,10,1],[134,13,134,62,1],[135,13,135,31,1],[136,13,136,30,1],[137,13,137,14,1],[138,17,138,63,1],[142,13,142,14,1],[143,17,143,151,1],[144,17,144,55,1],[145,13,145,14,1],[147,17,147,73,0],[148,13,148,14,0],[149,17,149,83,0],[152,13,152,43,1],[153,9,153,10,1],[162,9,162,10,1],[163,13,163,62,1],[164,13,164,31,1],[165,13,165,30,1],[166,13,166,14,1],[167,17,167,63,1],[171,13,171,14,1],[172,17,172,133,1],[173,13,173,14,1],[175,17,175,73,0],[176,13,176,14,0],[177,17,177,83,0],[179,13,179,43,1],[180,9,180,10,1],[191,9,191,10,1],[192,13,192,62,1],[193,13,193,31,1],[194,13,194,124,1],[195,13,195,38,1],[196,13,196,30,1],[197,13,197,14,1],[198,17,198,34,1],[199,17,199,55,1],[200,13,200,14,1],[201,13,201,25,1],[202,9,202,10,1],[213,9,213,10,1],[214,13,214,62,1],[215,13,215,31,1],[217,13,217,14,1],[218,17,218,209,1],[219,17,219,24,1],[219,25,219,31,1],[219,32,219,34,1],[219,35,219,48,1],[220,17,220,18,1],[221,21,221,75,1],[223,17,223,29,1],[227,16,227,91,1],[228,13,228,14,1],[229,17,229,84,1],[231,17,231,209,1],[232,17,232,24,1],[232,26,232,32,0],[232,33,232,35,1],[232,36,232,49,1],[233,17,233,18,0],[234,21,234,75,0],[236,17,236,29,1],[238,9,238,10,1],[247,9,247,10,1],[248,13,248,62,1],[249,13,249,31,1],[250,13,250,30,1],[251,13,251,14,1],[252,17,252,63,1],[257,13,257,14,1],[258,17,258,196,1],[259,17,259,38,1],[260,13,260,14,1],[262,17,262,92,1],[263,13,263,14,1],[264,17,264,94,1],[266,17,266,202,1],[267,17,267,38,1],[268,13,268,14,1],[270,13,270,30,1],[271,13,271,14,1],[272,17,272,41,1],[272,41,272,58,1],[272,58,272,69,1],[272,17,272,69,1],[274,13,274,39,0],[275,9,275,10,1],[285,9,285,10,1],[286,13,286,62,1],[287,13,287,31,1],[288,13,288,30,1],[289,13,289,14,1],[290,17,290,63,1],[292,13,292,32,1],[293,13,293,14,1],[294,17,294,65,1],[297,13,297,62,1],[297,62,297,86,1],[297,86,297,97,1],[297,13,297,97,1],[298,13,298,61,1],[299,13,299,20,1],[299,21,299,34,1],[299,35,299,37,1],[299,38,299,48,1],[300,13,300,14,1],[301,17,301,117,1],[302,13,302,14,1],[304,13,304,46,1],[305,9,305,10,1],[316,9,316,10,1],[317,13,317,62,1],[318,13,318,31,1],[319,13,319,30,1],[320,13,320,14,1],[321,17,321,63,1],[323,13,323,31,1],[324,13,324,14,0],[325,17,325,64,0],[327,13,327,34,1],[328,13,328,14,0],[329,17,329,67,0],[334,13,334,14,1],[335,17,335,196,1],[336,17,336,38,1],[337,13,337,14,1],[339,17,339,92,0],[340,13,340,14,0],[341,17,341,94,0],[343,17,343,202,0],[344,17,344,38,0],[345,13,345,14,0],[347,13,347,65,1],[348,13,348,20,1],[348,21,348,27,1],[348,28,348,30,1],[348,31,348,35,1],[349,13,349,14,1],[350,17,350,35,1],[351,17,351,80,1],[352,17,352,18,1],[353,21,353,50,1],[354,21,354,52,1],[356,21,356,113,1],[357,17,357,18,1],[358,13,358,14,1],[359,9,359,10,1],[369,9,369,10,1],[370,13,370,31,1],[371,13,371,30,1],[372,13,372,14,1],[373,17,373,63,1],[375,13,375,32,1],[376,13,376,14,1],[377,17,377,65,1],[382,13,382,14,1],[383,17,383,196,1],[384,17,384,38,1],[385,13,385,14,1],[387,17,387,92,0],[388,13,388,14,0],[389,17,389,94,0],[391,17,391,202,0],[392,17,392,38,0],[393,13,393,14,0],[395,13,395,30,1],[396,13,396,14,1],[397,17,397,63,1],[398,17,398,24,1],[398,26,398,35,1],[398,36,398,38,1],[398,39,398,45,1],[399,17,399,18,1],[400,21,400,60,1],[400,60,400,130,1],[400,130,400,132,1],[400,21,400,132,1],[401,21,401,43,1],[402,21,402,22,1],[403,25,403,127,1],[404,21,404,22,1],[405,17,405,18,1],[407,17,407,50,1],[408,13,408,14,1],[409,9,409,10,1],[420,9,420,10,1],[421,13,421,62,1],[422,13,422,31,1],[423,13,423,30,1],[424,13,424,14,1],[425,17,425,63,1],[427,13,427,31,1],[428,13,428,14,1],[429,17,429,64,1],[432,13,432,124,1],[433,9,433,10,1],[445,9,445,10,1],[446,13,446,62,1],[447,13,447,31,1],[448,13,448,30,1],[449,13,449,14,1],[450,17,450,63,1],[453,13,453,77,1],[455,13,455,20,1],[455,22,455,28,1],[455,29,455,31,1],[455,32,455,36,1],[456,13,456,14,1],[457,17,457,38,1],[458,17,458,94,1],[459,17,459,18,1],[460,21,460,112,1],[461,17,461,18,1],[462,13,462,14,1],[463,9,463,10,1],[474,9,474,10,1],[475,13,475,62,1],[476,13,476,31,1],[477,13,477,30,1],[478,13,478,14,1],[479,17,479,63,1],[484,13,484,14,1],[485,17,485,196,1],[486,17,486,38,1],[487,13,487,14,1],[489,17,489,92,1],[490,13,490,14,1],[491,17,491,90,1],[493,17,493,202,1],[494,17,494,38,1],[495,13,495,14,1],[497,13,497,30,1],[498,13,498,14,1],[499,17,500,34,1],[500,34,500,106,1],[500,106,501,31,1],[499,17,501,31,1],[503,13,503,47,0],[504,9,504,10,1],[517,9,517,10,1],[518,13,518,62,1],[519,13,519,31,1],[520,13,520,101,1],[521,13,521,35,1],[522,13,522,14,1],[523,17,523,81,1],[525,13,525,25,1],[526,9,526,10,1],[537,9,537,10,1],[538,13,538,62,1],[539,13,539,31,1],[542,13,542,14,1],[543,17,543,203,1],[544,17,544,24,1],[544,26,544,32,1],[544,33,544,35,1],[544,36,544,49,1],[545,17,545,18,1],[546,21,546,75,1],[548,17,548,29,1],[552,17,552,92,0],[553,13,553,14,0],[554,17,554,84,0],[556,17,556,203,0],[557,17,557,24,0],[557,26,557,32,0],[557,33,557,35,0],[557,36,557,49,0],[558,17,558,18,0],[559,21,559,75,0],[561,17,561,29,0],[564,9,564,10,1],[575,9,575,10,1],[576,13,576,62,1],[577,13,577,31,1],[578,13,578,31,1],[579,13,579,14,0],[580,17,580,64,0],[585,13,585,14,1],[586,17,586,202,1],[587,17,587,38,1],[588,13,588,14,1],[590,17,590,92,0],[591,13,591,14,0],[592,17,592,94,0],[594,17,594,208,0],[595,17,595,38,0],[596,13,596,14,0],[598,13,598,30,1],[599,13,599,14,0],[600,17,600,43,0],[603,13,603,50,1],[603,50,603,77,1],[603,77,603,91,1],[603,91,603,99,1],[603,99,603,101,1],[603,13,603,101,1],[604,13,604,52,1],[605,13,605,60,1],[606,13,606,20,1],[606,22,606,32,1],[606,33,606,35,1],[606,36,606,43,1],[607,13,607,14,1],[608,17,608,51,1],[608,51,608,52,1],[608,52,609,21,1],[609,21,609,79,1],[609,79,610,21,1],[610,21,610,38,1],[610,38,611,21,1],[611,21,611,22,1],[611,22,612,25,1],[612,25,612,41,1],[612,41,613,21,1],[613,21,613,22,1],[613,22,614,17,1],[614,17,614,18,1],[614,18,614,21,1],[608,17,614,21,1],[615,13,615,14,1],[617,13,617,46,1],[619,13,619,35,1],[620,9,620,10,1],[631,9,631,10,0],[632,13,632,94,0],[633,9,633,10,0],[643,9,643,10,0],[644,13,644,86,0],[645,9,645,10,0],[654,9,654,10,1],[655,13,655,64,1],[656,9,656,10,1],[666,9,666,10,1],[667,13,667,73,1],[668,9,668,10,1],[677,9,677,10,1],[678,13,678,72,1],[679,9,679,10,1],[690,9,690,10,0],[691,13,691,76,0],[692,13,692,30,0],[693,13,693,14,0],[694,17,694,56,0],[694,56,694,120,0],[694,120,694,122,0],[694,17,694,122,0],[696,13,696,25,0],[697,9,697,10,0],[707,9,707,10,1],[710,13,710,14,1],[711,17,711,205,1],[712,17,712,38,1],[713,13,713,14,1],[715,17,715,92,1],[716,13,716,14,1],[717,17,717,90,1],[719,17,719,211,1],[720,17,720,38,1],[721,13,721,14,1],[723,13,723,30,1],[724,13,724,14,1],[725,17,725,56,1],[725,56,725,120,1],[725,120,725,122,1],[725,17,725,122,1],[727,13,727,25,0],[728,9,728,10,1],[737,9,737,10,1],[738,13,738,135,1],[739,13,739,60,1],[740,9,740,10,1],[750,9,750,10,1],[751,13,751,110,1],[752,9,752,10,1],[755,9,755,10,1],[758,13,758,14,1],[759,17,759,195,1],[760,17,760,38,1],[761,13,761,14,1],[763,17,763,92,0],[764,13,764,14,0],[765,17,765,90,0],[767,17,767,201,0],[768,17,768,38,0],[769,13,769,14,0],[771,13,771,25,1],[772,9,772,10,1],[776,9,776,10,1],[777,13,777,32,1],[778,9,778,10,1],[781,9,781,10,1],[782,13,782,95,1],[783,13,783,62,1],[784,13,784,51,1],[785,13,785,72,1],[786,9,786,10,1]]);
    </script>
  </body>
</html>